//
// (c) 2015 DS Data Systems UK Ltd, All rights reserved.
//
// DS Data Systems and KonaKart and their respective logos, are 
// trademarks of DS Data Systems UK Ltd. All rights reserved.
//
// The information in this document is the proprietary property of
// DS Data Systems UK Ltd. and is protected by English copyright law,
// the laws of foreign jurisdictions, and international treaties,
// as applicable. No part of this document may be reproduced,
// transmitted, transcribed, transferred, modified, published, or
// translated into any language, in any form or by any means, for
// any purpose other than expressly permitted by DS Data Systems UK Ltd.
// in writing.
//
package com.konakart.app;

import java.math.BigDecimal;
import java.util.Calendar;

import com.konakart.app.KKException;

import com.konakart.appif.*;
import com.konakart.util.KKConstants;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 *  The KonaKart Custom Engine - Generated by CreateKKCustomEng
 */
@SuppressWarnings("all")
public class KKCustomEng implements com.konakart.appif.KKEngIf
{
     private KKEng kkEng = null;

    /**
     * Configuration parameter passed when the engine is instantiated
     */
     private EngineConfigIf engConf = null;

     protected static Log log = LogFactory.getLog(KKCustomEng.class);

    /**
     *  These are all the interface objects that you can override.
     *
     *  Replace the required custom class with one that implements
     *  your custom code.
     */
     private GetLanguages _getLanguages = null;
     private GetAllLanguages _getAllLanguages = null;
     private GetDefaultLanguage _getDefaultLanguage = null;
     private GetLanguagePerCode _getLanguagePerCode = null;
     private GetLanguagePerId _getLanguagePerId = null;
     private GetCategoryTree _getCategoryTree = null;
     private GetCategoryTreeWithOptions _getCategoryTreeWithOptions = null;
     private GetProductsPerCategory _getProductsPerCategory = null;
     private GetProductsPerCategoryWithOptions _getProductsPerCategoryWithOptions = null;
     private GetProductsPerCategoryPerManufacturer _getProductsPerCategoryPerManufacturer = null;
     private GetProductsPerCategoryPerManufacturerWithOptions _getProductsPerCategoryPerManufacturerWithOptions = null;
     private GetProductsPerManufacturer _getProductsPerManufacturer = null;
     private GetProductsPerManufacturerWithOptions _getProductsPerManufacturerWithOptions = null;
     private GetProduct _getProduct = null;
     private GetProductWithOptions _getProductWithOptions = null;
     private GetCategoriesPerManufacturer _getCategoriesPerManufacturer = null;
     private GetCategoriesPerProduct _getCategoriesPerProduct = null;
     private GetManufacturersPerCategory _getManufacturersPerCategory = null;
     private GetManufacturers _getManufacturers = null;
     private GetAllManufacturers _getAllManufacturers = null;
     private GetManufacturerPerProduct _getManufacturerPerProduct = null;
     private GetManufacturer _getManufacturer = null;
     private GetCategory _getCategory = null;
     private GetSpecialsPerCategory _getSpecialsPerCategory = null;
     private GetAllSpecials _getAllSpecials = null;
     private GetAllProducts _getAllProducts = null;
     private GetAllProductsWithOptions _getAllProductsWithOptions = null;
     private GetReviewsPerProduct _getReviewsPerProduct = null;
     private GetReview _getReview = null;
     private GetAllReviews _getAllReviews = null;
     private GetReviews _getReviews = null;
     private SearchForProducts _searchForProducts = null;
     private SearchForProductsWithOptions _searchForProductsWithOptions = null;
     private RegisterCustomer _registerCustomer = null;
     private ForceRegisterCustomer _forceRegisterCustomer = null;
     private GetAllCountries _getAllCountries = null;
     private Login _login = null;
     private Logout _logout = null;
     private GetAddressesPerCustomer _getAddressesPerCustomer = null;
     private GetAddressesPerManufacturer _getAddressesPerManufacturer = null;
     private GetAddressesPerProduct _getAddressesPerProduct = null;
     private GetAddressesPerStore _getAddressesPerStore = null;
     private GetDefaultAddressPerCustomer _getDefaultAddressPerCustomer = null;
     private SetDefaultAddressPerCustomer _setDefaultAddressPerCustomer = null;
     private AddAddressToCustomer _addAddressToCustomer = null;
     private DeleteAddressFromCustomer _deleteAddressFromCustomer = null;
     private EditCustomerAddress _editCustomerAddress = null;
     private GetCustomer _getCustomer = null;
     private EditCustomer _editCustomer = null;
     private GetKonakartTimeStamp _getKonakartTimeStamp = null;
     private WriteReview _writeReview = null;
     private CheckSession _checkSession = null;
     private AddToBasket _addToBasket = null;
     private AddToBasketWithOptions _addToBasketWithOptions = null;
     private MergeBaskets _mergeBaskets = null;
     private MergeBasketsWithOptions _mergeBasketsWithOptions = null;
     private UpdateBasket _updateBasket = null;
     private UpdateBasketWithOptions _updateBasketWithOptions = null;
     private RemoveFromBasket _removeFromBasket = null;
     private RemoveBasketItemsPerCustomer _removeBasketItemsPerCustomer = null;
     private GetBasketItemsPerCustomer _getBasketItemsPerCustomer = null;
     private GetBasketItemsPerCustomerWithOptions _getBasketItemsPerCustomerWithOptions = null;
     private GetDefaultCurrency _getDefaultCurrency = null;
     private GetAllCurrencies _getAllCurrencies = null;
     private GetConfigurations _getConfigurations = null;
     private GetConfiguration _getConfiguration = null;
     private GetConfigurationValue _getConfigurationValue = null;
     private GetConfigurationValueAsInt _getConfigurationValueAsInt = null;
     private GetConfigurationValueAsIntWithDefault _getConfigurationValueAsIntWithDefault = null;
     private GetConfigurationValueAsBigDecimal _getConfigurationValueAsBigDecimal = null;
     private GetConfigurationValueAsBigDecimalWithDefault _getConfigurationValueAsBigDecimalWithDefault = null;
     private GetConfigurationValueAsBool _getConfigurationValueAsBool = null;
     private EditConfiguration _editConfiguration = null;
     private ChangePassword _changePassword = null;
     private GetProductNotificationsPerCustomer _getProductNotificationsPerCustomer = null;
     private GetProductNotificationsPerCustomerWithOptions _getProductNotificationsPerCustomerWithOptions = null;
     private AddProductNotificationToCustomer _addProductNotificationToCustomer = null;
     private DeleteProductNotificationFromCustomer _deleteProductNotificationFromCustomer = null;
     private UpdateProductViewedCount _updateProductViewedCount = null;
     private GetBestSellers _getBestSellers = null;
     private GetBestSellersWithOptions _getBestSellersWithOptions = null;
     private GetOrdersPerCustomer _getOrdersPerCustomer = null;
     private SearchForOrdersPerCustomer _searchForOrdersPerCustomer = null;
     private GetOrder _getOrder = null;
     private GetCurrency _getCurrency = null;
     private CreateOrder _createOrder = null;
     private CreateOrderWithOptions _createOrderWithOptions = null;
     private GetOrderHistory _getOrderHistory = null;
     private GetOrderHistoryWithOptions _getOrderHistoryWithOptions = null;
     private GetAlsoPurchased _getAlsoPurchased = null;
     private GetAlsoPurchasedWithOptions _getAlsoPurchasedWithOptions = null;
     private GetRelatedProducts _getRelatedProducts = null;
     private GetRelatedProductsWithOptions _getRelatedProductsWithOptions = null;
     private GetCountryPerName _getCountryPerName = null;
     private GetCountry _getCountry = null;
     private GetShippingQuotes _getShippingQuotes = null;
     private GetShippingQuote _getShippingQuote = null;
     private ChangeDeliveryAddress _changeDeliveryAddress = null;
     private GetTaxRate _getTaxRate = null;
     private GetTax _getTax = null;
     private AddTax _addTax = null;
     private GetOrderTotals _getOrderTotals = null;
     private GetPaymentGateways _getPaymentGateways = null;
     private GetPaymentGateway _getPaymentGateway = null;
     private GetPaymentDetails _getPaymentDetails = null;
     private GetPaymentDetailsPerOrder _getPaymentDetailsPerOrder = null;
     private GetPaymentDetailsCustom _getPaymentDetailsCustom = null;
     private SaveOrder _saveOrder = null;
     private GetStatusText _getStatusText = null;
     private UpdateOrder _updateOrder = null;
     private ChangeOrderStatus _changeOrderStatus = null;
     private UpdateInventory _updateInventory = null;
     private UpdateInventoryWithOptions _updateInventoryWithOptions = null;
     private SendNewPassword _sendNewPassword = null;
     private SendNewPassword1 _sendNewPassword1 = null;
     private SendWelcomeEmail _sendWelcomeEmail = null;
     private SendWelcomeEmail1 _sendWelcomeEmail1 = null;
     private SendOrderConfirmationEmail _sendOrderConfirmationEmail = null;
     private SendOrderConfirmationEmail1 _sendOrderConfirmationEmail1 = null;
     private GetSecretKeyForOrderId _getSecretKeyForOrderId = null;
     private GetOrderIdFromSecretKey _getOrderIdFromSecretKey = null;
     private DeleteOrderIdForSecretKey _deleteOrderIdForSecretKey = null;
     private SaveIpnHistory _saveIpnHistory = null;
     private UpdateManufacturerViewedCount _updateManufacturerViewedCount = null;
     private GetZonesPerCountry _getZonesPerCountry = null;
     private SearchForZones _searchForZones = null;
     private UpdateCachedConfigurations _updateCachedConfigurations = null;
     private DoesCustomerExistForEmail _doesCustomerExistForEmail = null;
     private IsEmailValid _isEmailValid = null;
     private UpdateBasketWithStockInfo _updateBasketWithStockInfo = null;
     private UpdateBasketWithStockInfoWithOptions _updateBasketWithStockInfoWithOptions = null;
     private GetProductQuantity _getProductQuantity = null;
     private GetProductQuantityWithOptions _getProductQuantityWithOptions = null;
     private CreateAndSaveOrder _createAndSaveOrder = null;
     private GetSku _getSku = null;
     private SetEndpoint _setEndpoint = null;
     private InsertDigitalDownload _insertDigitalDownload = null;
     private GetDigitalDownloads _getDigitalDownloads = null;
     private GetDigitalDownloadsWithOptions _getDigitalDownloadsWithOptions = null;
     private UpdateDigitalDownloadCount _updateDigitalDownloadCount = null;
     private UpdateDigitalDownloadCountById _updateDigitalDownloadCountById = null;
     private GetTempCustomerId _getTempCustomerId = null;
     private GetAllCustomerGroups _getAllCustomerGroups = null;
     private GetCustomerGroup _getCustomerGroup = null;
     private SendTemplateEmailToCustomer _sendTemplateEmailToCustomer = null;
     private SendTemplateEmailToCustomer1 _sendTemplateEmailToCustomer1 = null;
     private LoginByAdmin _loginByAdmin = null;
     private Custom _custom = null;
     private CustomSecure _customSecure = null;
     private GetTagGroupsPerCategory _getTagGroupsPerCategory = null;
     private GetTagGroupsPerCategoryWithOptions _getTagGroupsPerCategoryWithOptions = null;
     private GetTagsPerCategory _getTagsPerCategory = null;
     private GetTagGroup _getTagGroup = null;
     private GetTag _getTag = null;
     private GetDefaultCustomer _getDefaultCustomer = null;
     private GetStoreIds _getStoreIds = null;
     private SetCreditCardDetailsOnOrder _setCreditCardDetailsOnOrder = null;
     private AddToWishList _addToWishList = null;
     private AddToWishListWithOptions _addToWishListWithOptions = null;
     private CreateWishList _createWishList = null;
     private CreateWishListWithOptions _createWishListWithOptions = null;
     private EditWishList _editWishList = null;
     private EditWishListWithOptions _editWishListWithOptions = null;
     private DeleteWishList _deleteWishList = null;
     private DeleteWishListWithOptions _deleteWishListWithOptions = null;
     private GetWishListWithItems _getWishListWithItems = null;
     private GetWishListWithItemsWithOptions _getWishListWithItemsWithOptions = null;
     private GetWishList _getWishList = null;
     private GetWishListWithOptions _getWishListWithOptions = null;
     private GetWishListItemsWithOptions _getWishListItemsWithOptions = null;
     private GetWishListItems _getWishListItems = null;
     private RemoveFromWishList _removeFromWishList = null;
     private RemoveFromWishListWithOptions _removeFromWishListWithOptions = null;
     private MergeWishListsWithOptions _mergeWishListsWithOptions = null;
     private SearchForWishLists _searchForWishLists = null;
     private GetStore _getStore = null;
     private AddCustomDataToSession _addCustomDataToSession = null;
     private GetCustomDataFromSession _getCustomDataFromSession = null;
     private SetCookie _setCookie = null;
     private GetCookie _getCookie = null;
     private GetAllCookies _getAllCookies = null;
     private DeleteCookie _deleteCookie = null;
     private GetGeoZonesPerZone _getGeoZonesPerZone = null;
     private InsertCustomerTag _insertCustomerTag = null;
     private InsertCustomerTagForGuest _insertCustomerTagForGuest = null;
     private AddToCustomerTag _addToCustomerTag = null;
     private AddToCustomerTagForGuest _addToCustomerTagForGuest = null;
     private GetCustomerTag _getCustomerTag = null;
     private GetCustomerTagForGuest _getCustomerTagForGuest = null;
     private GetCustomerTagValue _getCustomerTagValue = null;
     private GetCustomerTagValueForGuest _getCustomerTagValueForGuest = null;
     private DeleteCustomerTag _deleteCustomerTag = null;
     private DeleteCustomerTagForGuest _deleteCustomerTagForGuest = null;
     private GetCustomerTags _getCustomerTags = null;
     private GetCustomerTagsForGuest _getCustomerTagsForGuest = null;
     private EvaluateExpression _evaluateExpression = null;
     private EvaluateExpressionForGuest _evaluateExpressionForGuest = null;
     private GetExpression _getExpression = null;
     private GetExpressionForGuest _getExpressionForGuest = null;
     private PointsAvailable _pointsAvailable = null;
     private AddPoints _addPoints = null;
     private DeletePoints _deletePoints = null;
     private ReservePoints _reservePoints = null;
     private DeleteReservedPoints _deleteReservedPoints = null;
     private FreeReservedPoints _freeReservedPoints = null;
     private SetRewardPointReservationId _setRewardPointReservationId = null;
     private GetRewardPointsWithOptions _getRewardPointsWithOptions = null;
     private GetRewardPoints _getRewardPoints = null;
     private InsertSubscription _insertSubscription = null;
     private UpdateSubscription _updateSubscription = null;
     private GetPaymentSchedule _getPaymentSchedule = null;
     private GetSubscriptionsPerCustomer _getSubscriptionsPerCustomer = null;
     private SearchForSubscriptionsPerCustomer _searchForSubscriptionsPerCustomer = null;
     private GetProductPerSkuWithOptions _getProductPerSkuWithOptions = null;
     private GetProductPerSku _getProductPerSku = null;
     private GetIpnHistory _getIpnHistory = null;
     private GetPdf _getPdf = null;
     private GetDigitalDownloadById _getDigitalDownloadById = null;
     private EditDigitalDownload _editDigitalDownload = null;
     private GetMsgValue _getMsgValue = null;
     private GetMessages _getMessages = null;
     private PostMessageToQueue _postMessageToQueue = null;
     private ReadMessageFromQueue _readMessageFromQueue = null;
     private InsertCustomerEvent _insertCustomerEvent = null;
     private GetSuggestedSearchItems _getSuggestedSearchItems = null;
     private GetSuggestedSpellingItems _getSuggestedSpellingItems = null;
     private GetProductsFromIdsWithOptions _getProductsFromIdsWithOptions = null;
     private GetBookingsPerProduct _getBookingsPerProduct = null;
     private GetBookingsPerCustomer _getBookingsPerCustomer = null;
     private InsertBooking _insertBooking = null;
     private GetBookableProductConflict _getBookableProductConflict = null;
     private GetOrderStatus _getOrderStatus = null;
     private GetAllOrderStatuses _getAllOrderStatuses = null;
     private SaveSSOToken _saveSSOToken = null;
     private GetSSOToken _getSSOToken = null;
     private EnableCustomer _enableCustomer = null;
     private CheckCoupon _checkCoupon = null;
     private GetAllPromotions _getAllPromotions = null;
     private GetPromotionsPerProducts _getPromotionsPerProducts = null;
     private GetConfigData _getConfigData = null;
     private GetKonaKartVersion _getKonaKartVersion = null;
     private GetPunchOutMessage _getPunchOutMessage = null;
     private AddCustomerNotifications _addCustomerNotifications = null;
     private DeleteCustomerNotifications _deleteCustomerNotifications = null;
     private GetAddressFormatTemplate _getAddressFormatTemplate = null;
     private GetBundlesThatProductBelongsTo _getBundlesThatProductBelongsTo = null;
     private GetBundlesThatProductsBelongTo _getBundlesThatProductsBelongTo = null;
     private GetProductImages _getProductImages = null;
     private InsertKKEvent _insertKKEvent = null;
     private GetKKEvents _getKKEvents = null;
     private ProcessKKEvents _processKKEvents = null;
     private ValidatePassword _validatePassword = null;
     private GetCouponsPerCode _getCouponsPerCode = null;
     private GetCouponPerId _getCouponPerId = null;
     private GetPromotionsPerCoupon _getPromotionsPerCoupon = null;
     private GetContent _getContent = null;
     private GetContents _getContents = null;
     private GetContentType _getContentType = null;
     private GetContentTypes _getContentTypes = null;

   /**
    * Constructor
    *
    * @deprecated From version 2.2.7.0, you should use the constructor that receives an
    *             EngineConfigIf object
    * @throws KKException
    */
    @Deprecated
    public KKCustomEng() throws KKException
    {
        EngineConfigIf engConfig = new EngineConfig();
        engConfig.setStoreId(KKConstants.KONAKART_DEFAULT_STORE_ID);
        engConfig.setMode(EngineConfig.MODE_SINGLE_STORE);

        this.engConf = engConfig;
        kkEng = new KKEng(engConfig);
    }

   /**
    * Constructor
    * 
    * @param engConfig 
    * @throws KKException
    */
    public KKCustomEng(EngineConfigIf engConfig) throws KKException
    {
        this.engConf = engConfig;
        kkEng = new KKEng(engConfig);
    }

   /**
    * Common code to manage exceptions in the KKEng engine
    * 
    * @param e
    * @return a new KKException if the exception specified is not already a KKException
    */
    protected KKException manageThrowable(Throwable e)
    {
        if (log.isDebugEnabled())
        {
             log.debug("KKEng threw an exception:", e);
        }
        if (e.getClass().getName().equals("com.konakart.app.KKException"))
        {
            return (com.konakart.app.KKException) (e);
        }
        return new KKException(e);
    }

    /**
     * Returns an array of Language classes containing all of the languages that satisfy the search
     * criteria.
     * 
     * @param search
     *            criteria
     * @return Array of Language objects
     * @throws KKException
     */
     public LanguageIf[] getLanguages(LanguageSearchIf search) throws KKException
     {
         try
         {
            if (_getLanguages == null)
            {
                _getLanguages = new GetLanguages(kkEng);
            }

            return _getLanguages.getLanguages(search);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Language classes containing all of the languages that have been defined
     * within the system. It returns only the languages used for data definitions where language
     * variants are required (such as in products, categories etc) hence it does not return the
     * display-only languages.
     * 
     * @return Array of Language objects
     * @throws KKException
     */
     public LanguageIf[] getAllLanguages() throws KKException
     {
         try
         {
            if (_getAllLanguages == null)
            {
                _getAllLanguages = new GetAllLanguages(kkEng);
            }

            return _getAllLanguages.getAllLanguages();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The default language is referenced by a configuration variable called DEFAULT_LANGUAGE. If
     * this variable isn't set, then the method returns the language with the lowest sort order
     * value. We assume that this language is the default language and will be used when no other
     * language is specified.
     * 
     * @return Returns a language object
     * @throws KKException
     */
     public LanguageIf getDefaultLanguage() throws KKException
     {
         try
         {
            if (_getDefaultLanguage == null)
            {
                _getDefaultLanguage = new GetDefaultLanguage(kkEng);
            }

            return _getDefaultLanguage.getDefaultLanguage();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieves the language object referenced by the two letter code (i.e. en, de, es)
     * 
     * @param code
     *            The two letter language code such as en, de, es etc.
     * @return Returns a language object
     * @throws KKException
     */
     public LanguageIf getLanguagePerCode(String code) throws KKException
     {
         try
         {
            if (_getLanguagePerCode == null)
            {
                _getLanguagePerCode = new GetLanguagePerCode(kkEng);
            }

            return _getLanguagePerCode.getLanguagePerCode(code);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieves the language object referenced by the id.
     * 
     * @param languageId
     *            The numeric id of the language object
     * @return Returns a language object
     * @throws KKException
     */
     public LanguageIf getLanguagePerId(int languageId) throws KKException
     {
         try
         {
            if (_getLanguagePerId == null)
            {
                _getLanguagePerId = new GetLanguagePerId(kkEng);
            }

            return _getLanguagePerId.getLanguagePerId(languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a category tree structure consisting of an array of top level categories, each of
     * which may contain an array of child categories.
     * <p>
     * The name of the category is language dependent and will be returned in the language defined
     * by the <code>languageId</code> parameter.
     * <p>
     * Each Category class contains a <code>numberOfProducts</code> field that describes how many
     * products exist for that category. It is only calculated if the <code>getNumProducts</code>
     * input parameter is set to true. For performance reasons this parameter should be set to false
     * if <code>numberOfProducts</code> is not required.
     * <p>
     * If you do not set <code>numberOfProducts</code> to true beware that the category tree
     * returned will be a reference to the static category tree object and not a clone. This is only
     * relevant when using the POJO KKEng engine.
     * 
     * @param languageId
     *            The id for the language that will be used to determine the Category name. Value of
     *            -1 selects the default language.
     * @param getNumProducts
     *            A boolean that specifies whether the Category objects should have the
     *            numberOfProducts attribute set.
     * @return Array of Category objects
     * @throws KKException
     */
     public CategoryIf[] getCategoryTree(int languageId, boolean getNumProducts) throws KKException
     {
         try
         {
            if (_getCategoryTree == null)
            {
                _getCategoryTree = new GetCategoryTree(kkEng);
            }

            return _getCategoryTree.getCategoryTree(languageId, getNumProducts);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a category tree structure consisting of an array of top level categories, each of
     * which may contain an array of child categories.
     * <p>
     * The name of the category is language dependent and will be returned in the language defined
     * by the <code>languageId</code> parameter of the CategoryTreeOptions object.
     * <p>
     * Each Category class contains a <code>numberOfProducts</code> field that describes how many
     * products exist for that category. It is only calculated if the <code>getNumProducts</code>
     * input parameter of the CategoryTreeOptions object is set to true. For performance reasons
     * this parameter should be set to false if <code>numberOfProducts</code> is not required.
     * <p>
     * If the CategoryTreeOptions object has its returnClonedTree attribute set to true a cloned
     * version of the category tree will be returned. A cloned version of the category tree will
     * always be returned if you set the <code>numberOfProducts</code> to true. This is only
     * relevant when using the POJO KKEng engine.
     * 
     * @param options
     *            Category tree options object.
     * @return Array of Category objects
     * @throws KKException
     */
     public CategoryIf[] getCategoryTreeWithOptions(CategoryTreeOptionsIf options) throws KKException
     {
         try
         {
            if (_getCategoryTreeWithOptions == null)
            {
                _getCategoryTreeWithOptions = new GetCategoryTreeWithOptions(kkEng);
            }

            return _getCategoryTreeWithOptions.getCategoryTreeWithOptions(options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Products object for the given category and language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param searchInSubCats
     *            Determines whether products are searched for in the sub-categories of the
     *            specified category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerCategory(String sessionId, DataDescriptorIf dataDesc, int categoryId, boolean searchInSubCats, int languageId) throws KKException
     {
         try
         {
            if (_getProductsPerCategory == null)
            {
                _getProductsPerCategory = new GetProductsPerCategory(kkEng);
            }

            return _getProductsPerCategory.getProductsPerCategory(sessionId, dataDesc, categoryId, searchInSubCats, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getProductsPerCategory().
     * <p>
     * Returns a Products object for the given category and language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param searchInSubCats
     *            Determines whether products are searched for in the sub-categories of the
     *            specified category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerCategoryWithOptions(String sessionId, DataDescriptorIf dataDesc, int categoryId, boolean searchInSubCats, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductsPerCategoryWithOptions == null)
            {
                _getProductsPerCategoryWithOptions = new GetProductsPerCategoryWithOptions(kkEng);
            }

            return _getProductsPerCategoryWithOptions.getProductsPerCategoryWithOptions(sessionId, dataDesc, categoryId, searchInSubCats, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Products object for the given category, language and manufacturer.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerCategoryPerManufacturer(String sessionId, DataDescriptorIf dataDesc, int categoryId, int manufacturerId, int languageId) throws KKException
     {
         try
         {
            if (_getProductsPerCategoryPerManufacturer == null)
            {
                _getProductsPerCategoryPerManufacturer = new GetProductsPerCategoryPerManufacturer(kkEng);
            }

            return _getProductsPerCategoryPerManufacturer.getProductsPerCategoryPerManufacturer(sessionId, dataDesc, categoryId, manufacturerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getProductsPerCategoryPerManufacture().
     * <p>
     * Returns a Products object for the given category, language and manufacturer.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerCategoryPerManufacturerWithOptions(String sessionId, DataDescriptorIf dataDesc, int categoryId, int manufacturerId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductsPerCategoryPerManufacturerWithOptions == null)
            {
                _getProductsPerCategoryPerManufacturerWithOptions = new GetProductsPerCategoryPerManufacturerWithOptions(kkEng);
            }

            return _getProductsPerCategoryPerManufacturerWithOptions.getProductsPerCategoryPerManufacturerWithOptions(sessionId, dataDesc, categoryId, manufacturerId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Products object for the given manufacturer and language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerManufacturer(String sessionId, DataDescriptorIf dataDesc, int manufacturerId, int languageId) throws KKException
     {
         try
         {
            if (_getProductsPerManufacturer == null)
            {
                _getProductsPerManufacturer = new GetProductsPerManufacturer(kkEng);
            }

            return _getProductsPerManufacturer.getProductsPerManufacturer(sessionId, dataDesc, manufacturerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getProductsPerManufacturer().
     * <p>
     * Returns a Products object for the given manufacturer and language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getProductsPerManufacturerWithOptions(String sessionId, DataDescriptorIf dataDesc, int manufacturerId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductsPerManufacturerWithOptions == null)
            {
                _getProductsPerManufacturerWithOptions = new GetProductsPerManufacturerWithOptions(kkEng);
            }

            return _getProductsPerManufacturerWithOptions.getProductsPerManufacturerWithOptions(sessionId, dataDesc, manufacturerId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a complete Product object for the given <code>productId</code> and language.
     * <p>
     * Returns null if no product is found. The specialPrice is null if a special offer doesn't
     * exist for the product.
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return A Product object
     * @throws KKException
     */
     public ProductIf getProduct(String sessionId, int productId, int languageId) throws KKException
     {
         try
         {
            if (_getProduct == null)
            {
                _getProduct = new GetProduct(kkEng);
            }

            return _getProduct.getProduct(sessionId, productId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getProduct().
     * <p>
     * Returns a complete Product object for the given <code>productId</code> and language.
     * <p>
     * Returns null if no product is found. The specialPrice is null if a special offer doesn't
     * exist for the product.
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return A Product object
     * @throws KKException
     */
     public ProductIf getProductWithOptions(String sessionId, int productId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductWithOptions == null)
            {
                _getProductWithOptions = new GetProductWithOptions(kkEng);
            }

            return _getProductWithOptions.getProductWithOptions(sessionId, productId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of leaf Category objects for the given manufacturer.
     * 
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Array of Category objects
     * @throws KKException
     */
     public CategoryIf[] getCategoriesPerManufacturer(int manufacturerId, int languageId) throws KKException
     {
         try
         {
            if (_getCategoriesPerManufacturer == null)
            {
                _getCategoriesPerManufacturer = new GetCategoriesPerManufacturer(kkEng);
            }

            return _getCategoriesPerManufacturer.getCategoriesPerManufacturer(manufacturerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Category objects for the given product.
     * 
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Array of Category objects
     * @throws KKException
     */
     public CategoryIf[] getCategoriesPerProduct(int productId, int languageId) throws KKException
     {
         try
         {
            if (_getCategoriesPerProduct == null)
            {
                _getCategoriesPerProduct = new GetCategoriesPerProduct(kkEng);
            }

            return _getCategoriesPerProduct.getCategoriesPerProduct(productId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Manufacturer objects for the given category. They are sorted by name.
     * <p>
     * This method is normally used for fetching all the product manufacturers within a category so
     * that products may be filtered by manufacturer.
     * 
     * @param categoryId
     *            The numeric id of the category
     * @return Array of Manufacturer objects
     * @throws KKException
     */
     public ManufacturerIf[] getManufacturersPerCategory(int categoryId) throws KKException
     {
         try
         {
            if (_getManufacturersPerCategory == null)
            {
                _getManufacturersPerCategory = new GetManufacturersPerCategory(kkEng);
            }

            return _getManufacturersPerCategory.getManufacturersPerCategory(categoryId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Manufacturer objects that match the specified search criteria in the
     * ManufacturerSearch object. It allows you to search for:
     * <ul>
     * <li>Manufacturers with a specific name</li>
     * <li>A manufacturer by id</li>
     * <li>The manufacturer of a product from the product id</li>
     * <li>The manufacturers for all products within a category, from the category id</li>
     * </ul>
     * <p>
     * <code>dataDesc</code> controls the following functionality:
     * <ul>
     * <li>The maximum number of Manufacturer objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Manufacturer
     * objects, in order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only manufacturers
     * with a matching custom attribute value are returned.</li>
     * <li>The Manufacturers may be sorted by :
     * <ul>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param dataDesc
     *            The data descriptor object that defines the sort order, constraints on custom
     *            fields and offset and limit for paging.
     * @param search
     *            The Manufacturer search object that defines the search criteria
     * @param languageId
     *            The language id is used for language specific attributes of the manufacturer such
     *            as the URL.
     * @return Array of Manufacturer objects
     * @throws KKException
     */
     public ManufacturerIf[] getManufacturers(DataDescriptorIf dataDesc, ManufacturerSearchIf search, int languageId) throws KKException
     {
         try
         {
            if (_getManufacturers == null)
            {
                _getManufacturers = new GetManufacturers(kkEng);
            }

            return _getManufacturers.getManufacturers(dataDesc, search, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Manufacturer objects for all of the manufacturers in the system. They are
     * sorted by name.
     * <p>
     * If the system has a large number of manufacturers, it better to use the
     * <code>getManufacturers(DataDescriptorIf dataDesc, ManufacturerSearchIf search, int languageId)</code>
     * method where the DatDescriptor can be used to limit the number of manufacturers returned.
     * 
     * @return Array of Manufacturer objects
     * @throws KKException
     */
     public ManufacturerIf[] getAllManufacturers() throws KKException
     {
         try
         {
            if (_getAllManufacturers == null)
            {
                _getAllManufacturers = new GetAllManufacturers(kkEng);
            }

            return _getAllManufacturers.getAllManufacturers();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Manufacturer object for the given <code>productId</code> and language.
     * 
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Manufacturer object. Null if it doesn't exist.
     * @throws KKException
     */
     public ManufacturerIf getManufacturerPerProduct(int productId, int languageId) throws KKException
     {
         try
         {
            if (_getManufacturerPerProduct == null)
            {
                _getManufacturerPerProduct = new GetManufacturerPerProduct(kkEng);
            }

            return _getManufacturerPerProduct.getManufacturerPerProduct(productId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Manufacturer object for the given <code>manufacturerId</code> and language.
     * 
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Manufacturer object. Null if it doesn't exist.
     * @throws KKException
     */
     public ManufacturerIf getManufacturer(int manufacturerId, int languageId) throws KKException
     {
         try
         {
            if (_getManufacturer == null)
            {
                _getManufacturer = new GetManufacturer(kkEng);
            }

            return _getManufacturer.getManufacturer(manufacturerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a complete single Category object for the given <code>categoryId</code> and language.
     * It does not populate the children even if they exist. It does populate the MiscItem array.
     * 
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Category object
     * @throws KKException
     */
     public CategoryIf getCategory(int categoryId, int languageId) throws KKException
     {
         try
         {
            if (_getCategory == null)
            {
                _getCategory = new GetCategory(kkEng);
            }

            return _getCategory.getCategory(categoryId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all specials for the given <code>categoryId</code> and language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * <p>
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param searchInSubCats
     *            Determines whether products are searched for in the sub-categories of the
     *            specified category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getSpecialsPerCategory(String sessionId, DataDescriptorIf dataDesc, int categoryId, boolean searchInSubCats, int languageId) throws KKException
     {
         try
         {
            if (_getSpecialsPerCategory == null)
            {
                _getSpecialsPerCategory = new GetSpecialsPerCategory(kkEng);
            }

            return _getSpecialsPerCategory.getSpecialsPerCategory(sessionId, dataDesc, categoryId, searchInSubCats, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all specials using the given language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getAllSpecials(String sessionId, DataDescriptorIf dataDesc, int languageId) throws KKException
     {
         try
         {
            if (_getAllSpecials == null)
            {
                _getAllSpecials = new GetAllSpecials(kkEng);
            }

            return _getAllSpecials.getAllSpecials(sessionId, dataDesc, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all products using the given language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getAllProducts(String sessionId, DataDescriptorIf dataDesc, int languageId) throws KKException
     {
         try
         {
            if (_getAllProducts == null)
            {
                _getAllProducts = new GetAllProducts(kkEng);
            }

            return _getAllProducts.getAllProducts(sessionId, dataDesc, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getAllProducts().
     * <p>
     * Returns all products using the given language.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li> *
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf getAllProductsWithOptions(String sessionId, DataDescriptorIf dataDesc, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getAllProductsWithOptions == null)
            {
                _getAllProductsWithOptions = new GetAllProductsWithOptions(kkEng);
            }

            return _getAllProductsWithOptions.getAllProductsWithOptions(sessionId, dataDesc, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An array of review objects is returned for the given <code>productId</code>.
     * <p>
     * The <code>averageRating</code> attribute of the reviews is calculated and set by the method.
     * <p>
     * All reviews are retrieved, regardless of the language. <code>dataDesc</code> may be null. In
     * this case, the number of retrieved reviews is limited to a default number, the reviews are
     * ordered by the ReviewId and the offset is set to zero. However, by setting the attributes of
     * <code>dataDesc</code>, the following functionality may be controlled :
     * <ul>
     * <li>The maximum number of Review objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Review objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only reviews with a
     * matching custom attribute value are returned.</li>
     * <li>The Reviews may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param productId
     *            The numeric id of the product
     * @return Return a Reviews object
     * @throws KKException
     */
     public ReviewsIf getReviewsPerProduct(DataDescriptorIf dataDesc, int productId) throws KKException
     {
         try
         {
            if (_getReviewsPerProduct == null)
            {
                _getReviewsPerProduct = new GetReviewsPerProduct(kkEng);
            }

            return _getReviewsPerProduct.getReviewsPerProduct(dataDesc, productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An review object is returned for the given <code>reviewId</code>. The
     * <code>averageRating</code> attribute of the review is calculated and set by the method.
     * 
     * @param reviewId
     *            The numeric id of the review
     * @return Return a Review object
     * @throws KKException
     */
     public ReviewIf getReview(int reviewId) throws KKException
     {
         try
         {
            if (_getReview == null)
            {
                _getReview = new GetReview(kkEng);
            }

            return _getReview.getReview(reviewId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An array of review objects is returned. All reviews are retrieved, regardless of the
     * language.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved reviews is limited
     * to a default number, the reviews are ordered by the ReviewId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Review objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Review objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only reviews with a
     * matching custom attribute value are returned.</li>
     * <li>The Reviews may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_READ_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @return Return a Reviews object
     * @throws KKException
     */
     public ReviewsIf getAllReviews(DataDescriptorIf dataDesc) throws KKException
     {
         try
         {
            if (_getAllReviews == null)
            {
                _getAllReviews = new GetAllReviews(kkEng);
            }

            return _getAllReviews.getAllReviews(dataDesc);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Reviews (within a Reviews object) that match the specified search
     * criteria in the ReviewSearch object. It allows you to search for:
     * <ul>
     * <li>A review for a given reviewId</li>
     * <li>All reviews for a product identified by the productId</li>
     * <li>All reviews written by a customer identified by the customerId</li>
     * <li>All reviews matching, above or below a given rating</li>
     * </ul>
     * <p>
     * The ReviewSearch object also allows you to specify that the return data contains:
     * <ul>
     * <li>The average rating for all reviews matching the search criteria.</li>
     * <li>An array of name / number objects containing facet information for the number of reviews
     * present for each rating. The name identifies the rating and the number identifies the number
     * of reviews for that rating. No object is returned for a rating that has no reviews.</li>
     * </ul>
     * <p>
     * <code>dataDesc</code> controls the following functionality:
     * <ul>
     * <li>The maximum number of Review objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Review objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only reviews with a
     * matching custom attribute value are returned.</li>
     * <li>The Reviews may be sorted by :
     * <ul>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_TIMES_READ_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_TIMES_READ_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param dataDesc
     *            The data descriptor object that defines the sort order, constraints on custom
     *            fields and offset and limit for paging.
     * @param search
     *            The Review search object that defines the search criteria
     * @return Returns a Reviews object containing the return data
     * @throws KKException
     */
     public ReviewsIf getReviews(DataDescriptorIf dataDesc, ReviewSearchIf search) throws KKException
     {
         try
         {
            if (_getReviews == null)
            {
                _getReviews = new GetReviews(kkEng);
            }

            return _getReviews.getReviews(dataDesc, search);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all products using the given language. The ProductSearch class contains the search
     * criteria.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_SCORE_ASCENDING - When using Solr search engine</li>
     * <li>DataDescConstants.ORDER_BY_SCORE_DESCENDING - When using Solr search engine</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param prodSearch
     *            Contains information used to search the catalog for a product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf searchForProducts(String sessionId, DataDescriptorIf dataDesc, ProductSearchIf prodSearch, int languageId) throws KKException
     {
         try
         {
            if (_searchForProducts == null)
            {
                _searchForProducts = new SearchForProducts(kkEng);
            }

            return _searchForProducts.searchForProducts(sessionId, dataDesc, prodSearch, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to searchForProducts().
     * <p>
     * Returns all products using the given language. The ProductSearch class contains the search
     * criteria.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The description will only be
     * set if specified in the ProductSearch object passed in as a parameter. The specialPrice is
     * null if a special offer doesn't exist for the product.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved products is limited
     * to a default number, the products are ordered by the ProductId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Product objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Product objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Whether or not to return invisible products.</li>
     * <li>Whether or not to add an array of custom attributes.</li>
     * <li>Whether or not to add an array of miscellaneous items.</li>
     * <li>Whether or not to add the product description.</li>
     * <li>Whether or not to add the product options.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only products with a
     * matching custom attribute value are returned.</li>
     * <li>The Products may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_PRICE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_VIEWED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_TIMES_ORDERED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_RATING_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_MANUFACTURER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM6_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM7_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM8_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM9_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM10_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2INT_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1DEC_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2DEC_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param prodSearch
     *            Contains information used to search the catalog for a product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object
     * @throws KKException
     */
     public ProductsIf searchForProductsWithOptions(String sessionId, DataDescriptorIf dataDesc, ProductSearchIf prodSearch, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_searchForProductsWithOptions == null)
            {
                _searchForProductsWithOptions = new SearchForProductsWithOptions(kkEng);
            }

            return _searchForProductsWithOptions.searchForProductsWithOptions(sessionId, dataDesc, prodSearch, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Receives all of the necessary parameters from the Customer Registration object to create a
     * new customer in the database. If the customer has already registered, an exception is thrown
     * <p>
     * If the country has at least one zone defined in the database, then we verify that the State
     * attribute of the CustomerRegistration object matches one of the defined zones, otherwise a
     * kkInvalidZoneException is thrown. If a match is found, then the zoneId is saved in the
     * database table. If no zones are defined for the country, then we don't make the check and
     * save the State attribute directly in the database.
     * 
     * @param custReg
     *            Contains all the required data in order to register a new customer
     * @return Id of the customer that was created.
     * @throws KKException
     */
     public int registerCustomer(CustomerRegistrationIf custReg) throws KKException
     {
         try
         {
            if (_registerCustomer == null)
            {
                _registerCustomer = new RegisterCustomer(kkEng);
            }

            return _registerCustomer.registerCustomer(custReg);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This API Call is used rather than <code>registerCustomer()</code> when you want to provide a
     * store that doesn't force a customer to register. It registers a customer as a temporary
     * customer and allows you to register this customer more than once as long as the customer
     * remains temporary. i.e. Doesn't go through a proper registration process.
     * <p>
     * KonaKart requires a temporary customer (one that has never registered) to be present in its
     * database even if the store doesn't require registration. If a temporary customer with the
     * same eMail address already exists, then this customer is deleted. An exception is thrown if a
     * non-temporary customer (one that has registered) exists with the same eMail. You must still
     * supply a password (which can be randomly generated) which you must then use to log in the
     * customer so that he can checkout.
     * <p>
     * If your online store lets users choose whether to register or not, this method should be used
     * if a user decides not to register since you still require to gather the user's personal
     * details such as name and address.
     * <p>
     * If the country has at least one zone defined in the database, then we verify that the State
     * attribute of the CustomerRegistration object matches one of the defined zones, otherwise a
     * kkInvalidZoneException is thrown. If a match is found, then the zoneId is saved in the
     * database table. If no zones are defined for the country, then we don't make the check and
     * save the State attribute directly in the database.
     * 
     * @param custReg
     *            Contains all the required data in order to register a new customer
     * @return Id of the customer that was created.
     * @throws KKException
     */
     public int forceRegisterCustomer(CustomerRegistrationIf custReg) throws KKException
     {
         try
         {
            if (_forceRegisterCustomer == null)
            {
                _forceRegisterCustomer = new ForceRegisterCustomer(kkEng);
            }

            return _forceRegisterCustomer.forceRegisterCustomer(custReg);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Country objects for all of the countries in the system. They are sorted
     * by name. This method is used to create the drop list of countries during the customer
     * registration process.
     * 
     * @return Array of Country objects
     * @throws KKException
     */
     public CountryIf[] getAllCountries() throws KKException
     {
         try
         {
            if (_getAllCountries == null)
            {
                _getAllCountries = new GetAllCountries(kkEng);
            }

            return _getAllCountries.getAllCountries();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a 16 byte long session key is the login is successful, otherwise it returns null.
     * 
     * @param emailAddr
     *            The user name required to log in
     * @param password
     *            The log in password
     * @return sessionId The sessionId which must be used in subsequent API calls to identify the
     *         user
     * @throws KKException
     */
     public String login(String emailAddr, String password) throws KKException
     {
         try
         {
            if (_login == null)
            {
                _login = new Login(kkEng);
            }

            return _login.login(emailAddr, password);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Logs out the user with the specified session Id.
     * 
     * @param sessionId
     *            The session Id of the logged in user
     * @throws KKException
     */
     public void logout(String sessionId) throws KKException
     {
         try
         {
            if (_logout == null)
            {
                _logout = new Logout(kkEng);
            }

            _logout.logout(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all of the addresses registered for the given customer. An exception is thrown if the
     * sessionId isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return An array of address objects where the first one is the primary address. Returns an
     *         empty array if no addresses exist.
     * @throws KKException
     */
     public AddressIf[] getAddressesPerCustomer(String sessionId) throws KKException
     {
         try
         {
            if (_getAddressesPerCustomer == null)
            {
                _getAddressesPerCustomer = new GetAddressesPerCustomer(kkEng);
            }

            return _getAddressesPerCustomer.getAddressesPerCustomer(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets an array of Address objects that have been defined for the manufacturer referenced by
     * the manufacturerId.
     * 
     * @param manufacturerId
     * @return Returns an array of Address objects. Returns an empty array if no addresses exist.
     * @throws KKException
     */
     public AddressIf[] getAddressesPerManufacturer(int manufacturerId) throws KKException
     {
         try
         {
            if (_getAddressesPerManufacturer == null)
            {
                _getAddressesPerManufacturer = new GetAddressesPerManufacturer(kkEng);
            }

            return _getAddressesPerManufacturer.getAddressesPerManufacturer(manufacturerId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets an array of Address objects that have been defined for the product referenced by the
     * productId. The primary address(es) are first in the list.
     * 
     * @param productId
     * @return Returns an array of Address objects. Returns an empty array if no addresses exist.
     * @throws KKException
     */
     public AddressIf[] getAddressesPerProduct(int productId) throws KKException
     {
         try
         {
            if (_getAddressesPerProduct == null)
            {
                _getAddressesPerProduct = new GetAddressesPerProduct(kkEng);
            }

            return _getAddressesPerProduct.getAddressesPerProduct(productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets an array of Address objects that have been defined for the store referenced by the
     * addressStoreId.
     * 
     * @param addressStoreId
     * @return An array of address objects. Returns an empty array if no addresses exist or the
     *         addressStoreId is set to null.
     * @throws KKException
     */
     public AddressIf[] getAddressesPerStore(String addressStoreId) throws KKException
     {
         try
         {
            if (_getAddressesPerStore == null)
            {
                _getAddressesPerStore = new GetAddressesPerStore(kkEng);
            }

            return _getAddressesPerStore.getAddressesPerStore(addressStoreId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the default address for the given customer. An exception is thrown if the sessionId
     * isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return An address object or null if it doesn't exist.
     * @throws KKException
     */
     public AddressIf getDefaultAddressPerCustomer(String sessionId) throws KKException
     {
         try
         {
            if (_getDefaultAddressPerCustomer == null)
            {
                _getDefaultAddressPerCustomer = new GetDefaultAddressPerCustomer(kkEng);
            }

            return _getDefaultAddressPerCustomer.getDefaultAddressPerCustomer(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Sets the default address for this customer to be the address identified by
     * <code>addressId</code>. A check is made to determine whether an address exists with that id
     * and that it belongs to the customer logged in with this <code>sessionId</code>.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param addressId
     *            The numeric id of the address object
     * @throws KKException
     */
     public void setDefaultAddressPerCustomer(String sessionId, int addressId) throws KKException
     {
         try
         {
            if (_setDefaultAddressPerCustomer == null)
            {
                _setDefaultAddressPerCustomer = new SetDefaultAddressPerCustomer(kkEng);
            }

            _setDefaultAddressPerCustomer.setDefaultAddressPerCustomer(sessionId, addressId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The Address object is added to the customer defined by the <code>sessionId</code>. The id of
     * the address object is ignored since it is calculated during the insertion process. The zoneId
     * is also calculated unless addr.isUseZoneId()is set to true. In this case the zoneId from the
     * address object is used. The customerId of the address object is also ignored. An exception is
     * thrown if the sessionId isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param addr
     *            The address object which will be added to the customer
     * @return Id of the new address object. A negative return value indicates an error.
     * @throws KKException
     */

     public int addAddressToCustomer(String sessionId, AddressIf addr) throws KKException
     {
         try
         {
            if (_addAddressToCustomer == null)
            {
                _addAddressToCustomer = new AddAddressToCustomer(kkEng);
            }

            return _addAddressToCustomer.addAddressToCustomer(sessionId, addr);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The address defined by the <code>sessionId</code> and <code>addressId</code> is deleted. The
     * customerId is retrieved from the session. An exception is thrown if the session isn't valid
     * and if the address referenced by the <code>addressId</code> doesn't belong to the customer
     * referenced by the <code>sessionId</code>. An exception is also thrown if we attempt to delete
     * the default address.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param addressId
     *            The numeric id of the address object
     * @throws KKException
     */
     public void deleteAddressFromCustomer(String sessionId, int addressId) throws KKException
     {
         try
         {
            if (_deleteAddressFromCustomer == null)
            {
                _deleteAddressFromCustomer = new DeleteAddressFromCustomer(kkEng);
            }

            _deleteAddressFromCustomer.deleteAddressFromCustomer(sessionId, addressId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The Address object will replace the existing address object in the database with the same id.
     * A check is made to verify that the address object belongs to the customer logged in with the
     * <code>sessionId</code> passed in as a parameter. The zoneId is ignored since it is calculated
     * during the insertion process, unless addr.isUseZoneId()is set to true. In this case the
     * zoneId from the address object is used. The <code>addressId</code> is used to identify the
     * address object. The customerId attribute of the address object is ignored since it is
     * obtained from the <code>sessionId</code>. An exception is thrown if the session isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param addr
     *            The address object to edit
     * @throws KKException
     */
     public void editCustomerAddress(String sessionId, AddressIf addr) throws KKException
     {
         try
         {
            if (_editCustomerAddress == null)
            {
                _editCustomerAddress = new EditCustomerAddress(kkEng);
            }

            _editCustomerAddress.editCustomerAddress(sessionId, addr);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the customer object for the customer defined by the given <code>sessionId</code>.
     * Throws an exception if the session has expired.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Customer Object or Null if the customer doesn't exist.
     * @throws KKException
     */
     public CustomerIf getCustomer(String sessionId) throws KKException
     {
         try
         {
            if (_getCustomer == null)
            {
                _getCustomer = new GetCustomer(kkEng);
            }

            return _getCustomer.getCustomer(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The Customer object will replace the existing customer object in the database.
     * <code>cust</code> has to be the same customer logged in with a valid <code>sessionId</code>.
     * Only non null attributes or integers not equal to -1 will be used (i.e. set an integer field
     * to -1 if you do not want to change it).
     * <p>
     * The attributes from the Customer object that are used are :
     * <ul>
     * <li>gender</li>
     * <li>firstName</li>
     * <li>lastName</li>
     * <li>birthDate</li>
     * <li>emailAddr</li>
     * <li>faxNumber</li>
     * <li>telephoneNumber</li>
     * <li>telephoneNumber1</li>
     * <li>locale</li>
     * <li>newsletter</li>
     * <li>password</li>
     * <li>customerType</li>
     * <li>customerGroup</li>
     * <li>custom1</li>
     * <li>custom2</li>
     * <li>custom3</li>
     * <li>custom4</li>
     * <li>custom5</li>
     * <li>dateLastModified</li>
     * <li>globalProductNotifications</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param cust
     *            The customer object to edit
     * @throws KKException
     */
     public void editCustomer(String sessionId, CustomerIf cust) throws KKException
     {
         try
         {
            if (_editCustomer == null)
            {
                _editCustomer = new EditCustomer(kkEng);
            }

            _editCustomer.editCustomer(sessionId, cust);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get a Date Time Stamp from the server
     * 
     * @return Calendar
     * @throws KKException
     */
     public Calendar getKonakartTimeStamp() throws KKException
     {
         try
         {
            if (_getKonakartTimeStamp == null)
            {
                _getKonakartTimeStamp = new GetKonakartTimeStamp(kkEng);
            }

            return _getKonakartTimeStamp.getKonakartTimeStamp();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Receives all of the necessary parameters from the Review object to create a new review in the
     * database. The new review is associated to the customer logged in with <code>sessionId</code>.
     * <p>
     * The obligatory parameters are :
     * <ul>
     * <li>languageId</li>
     * <li>productId</li>
     * <li>rating</li>
     * <li>reviewText</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param review
     *            The review that will be inserted
     * @return Id of the review that was created.
     * @throws KKException
     */
     public int writeReview(String sessionId, ReviewIf review) throws KKException
     {
         try
         {
            if (_writeReview == null)
            {
                _writeReview = new WriteReview(kkEng);
            }

            return _writeReview.writeReview(sessionId, review);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The given <code>sessionId</code> is checked to see whether it exists and whether it is has
     * timed out. If it is valid, the expiry attribute is updated. An exception is thrown if it is
     * not valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Returns customerId of customer pointed to by session
     * @throws KKException
     */
     public int checkSession(String sessionId) throws KKException
     {
         try
         {
            if (_checkSession == null)
            {
                _checkSession = new CheckSession(kkEng);
            }

            return _checkSession.checkSession(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Saves the Basket object in the database for a customer. If the Basket object already exists
     * with exactly the same options etc, then we just increase the quantity of the existing object.
     * <p>
     * The Basket object does not have to be fully populated. The compulsory attributes are:
     * <ul>
     * <li>productId only if the product attribute is set to null</li>
     * <li>quantity</li>
     * <li>opts only if there are selected options</li>
     * </ul>
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param item
     *            The basket item to add to the basket
     * @return Returns the id of the newly created Basket object
     * @throws KKException
     */
     public int addToBasket(String sessionId, int customerId, BasketIf item) throws KKException
     {
         try
         {
            if (_addToBasket == null)
            {
                _addToBasket = new AddToBasket(kkEng);
            }

            return _addToBasket.addToBasket(sessionId, customerId, item);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If <code>options</code> is set to null, this method is identical to
     * <code>addToBasket()</code>. Otherwise the functionality differs depending on the combination
     * of options set.
     * <p>
     * Saves the Basket object in the database for a customer. If the Basket object already exists
     * with exactly the same options etc, then we either just increase the quantity of the existing
     * object or we add a new object. This depends on the options.
     * <p>
     * The Basket object does not have to be fully populated. The compulsory attributes are:
     * <ul>
     * <li>productId only if the product attribute is set to null</li>
     * <li>quantity</li>
     * <li>opts only if there are selected options</li>
     * </ul>
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param item
     *            The basket item to add to the basket
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns the id of the newly created Basket object
     * @throws KKException
     */
     public int addToBasketWithOptions(String sessionId, int customerId, BasketIf item, AddToBasketOptionsIf options) throws KKException
     {
         try
         {
            if (_addToBasketWithOptions == null)
            {
                _addToBasketWithOptions = new AddToBasketWithOptions(kkEng);
            }

            return _addToBasketWithOptions.addToBasketWithOptions(sessionId, customerId, item, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Add all items from the basket of customerFrom to the basket of the customer associated to the
     * <code>sessionId</code>. The customer receiving the basket items, must be logged on, which is
     * why the method parameter is a <code>sessionId</code> and not a <code>customerId</code>. This
     * method is normally called when a customer logs on, in order to move his temporary basket to
     * his permanent basket. The items are merged into the target basket. i.e. If a similar item
     * already exists, then the quantity is increased.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerFromId
     *            The numeric id of the customer that has the temporary basket
     * @throws KKException
     */
     public void mergeBaskets(String sessionId, int customerFromId) throws KKException
     {
         try
         {
            if (_mergeBaskets == null)
            {
                _mergeBaskets = new MergeBaskets(kkEng);
            }

            _mergeBaskets.mergeBaskets(sessionId, customerFromId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Add all items from the basket of customerFrom to the basket of the customer associated to the
     * <code>sessionId</code>. The customer receiving the basket items, must be logged on, which is
     * why the method parameter is a <code>sessionId</code> and not a <code>customerId</code>. This
     * method is normally called when a customer logs on, in order to move his temporary basket to
     * his permanent basket. The items are merged into the target basket. i.e. If a similar item
     * already exists, then the quantity is increased.
     * <p>
     * If options is set to null then this call is identical to mergeBaskets(). The options may
     * determine from where we read the price and quantity of the basket items.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerFromId
     *            The numeric id of the customer that has the temporary basket
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void mergeBasketsWithOptions(String sessionId, int customerFromId, AddToBasketOptionsIf options) throws KKException
     {
         try
         {
            if (_mergeBasketsWithOptions == null)
            {
                _mergeBasketsWithOptions = new MergeBasketsWithOptions(kkEng);
            }

            _mergeBasketsWithOptions.mergeBasketsWithOptions(sessionId, customerFromId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Updates the Basket object in the database.
     * <p>
     * The only attributes that may be changed are:
     * <ul>
     * <li>quantity</li>
     * <li>finalPrice</li>
     * <li>custom fields</li>
     * </ul>
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * <p>
     * A check is also made to ensure that the basket item being modified, actually belongs to the
     * customer.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param item
     *            The basket item to update
     * @throws KKException
     */
     public void updateBasket(String sessionId, int customerId, BasketIf item) throws KKException
     {
         try
         {
            if (_updateBasket == null)
            {
                _updateBasket = new UpdateBasket(kkEng);
            }

            _updateBasket.updateBasket(sessionId, customerId, item);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Updates the Basket object in the database.
     * <p>
     * The only attributes that may be changed are:
     * <ul>
     * <li>quantity</li>
     * <li>finalPrice</li>
     * <li>custom fields</li>
     * </ul>
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * <p>
     * A check is also made to ensure that the basket item being modified, actually belongs to the
     * customer.
     * <p>
     * If options is set to null, this method is identical to updateBasket(). Otherwise the
     * functionality differs depending on the combination of options set.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param item
     *            The basket item to update
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void updateBasketWithOptions(String sessionId, int customerId, BasketIf item, AddToBasketOptionsIf options) throws KKException
     {
         try
         {
            if (_updateBasketWithOptions == null)
            {
                _updateBasketWithOptions = new UpdateBasketWithOptions(kkEng);
            }

            _updateBasketWithOptions.updateBasketWithOptions(sessionId, customerId, item, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The Basket object is deleted.
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * <p>
     * A check is also made to ensure that the basket item being deleted, actually belongs to the
     * customer.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param item
     *            The basket item to delete
     * @throws KKException
     */
     public void removeFromBasket(String sessionId, int customerId, BasketIf item) throws KKException
     {
         try
         {
            if (_removeFromBasket == null)
            {
                _removeFromBasket = new RemoveFromBasket(kkEng);
            }

            _removeFromBasket.removeFromBasket(sessionId, customerId, item);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * All Basket objects that exist for this customer are deleted.
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code>, ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @throws KKException
     */
     public void removeBasketItemsPerCustomer(String sessionId, int customerId) throws KKException
     {
         try
         {
            if (_removeBasketItemsPerCustomer == null)
            {
                _removeBasketItemsPerCustomer = new RemoveBasketItemsPerCustomer(kkEng);
            }

            _removeBasketItemsPerCustomer.removeBasketItemsPerCustomer(sessionId, customerId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get the basket items for a customer and language.
     * <p>
     * Each basket item has an instantiated product object.
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code> , ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an array of Basket objects
     * @throws KKException
     */
     public BasketIf[] getBasketItemsPerCustomer(String sessionId, int customerId, int languageId) throws KKException
     {
         try
         {
            if (_getBasketItemsPerCustomer == null)
            {
                _getBasketItemsPerCustomer = new GetBasketItemsPerCustomer(kkEng);
            }

            return _getBasketItemsPerCustomer.getBasketItemsPerCustomer(sessionId, customerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get the basket items for a customer and language. Each basket item has an instantiated
     * product object.
     * <p>
     * If the customer is logged in to the application, then a valid <code>sessionId</code> is
     * required and the <code>customerId</code> is ignored. Otherwise, the <code>sessionId</code>
     * may be set to null and the method will use the <code>customerId</code> , ensuring that the
     * customer is not a registered customer by checking that the <code>customerId</code> is
     * negative. All registered customers have positive ids.
     * <p>
     * If options is set to null then this call is identical to getBasketItemsPerCustomer(). The
     * options may determine from where we read the price and quantity of the basket items.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param customerId
     *            The numeric id of the customer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of Basket objects
     * @throws KKException
     */
     public BasketIf[] getBasketItemsPerCustomerWithOptions(String sessionId, int customerId, int languageId, AddToBasketOptionsIf options) throws KKException
     {
         try
         {
            if (_getBasketItemsPerCustomerWithOptions == null)
            {
                _getBasketItemsPerCustomerWithOptions = new GetBasketItemsPerCustomerWithOptions(kkEng);
            }

            return _getBasketItemsPerCustomerWithOptions.getBasketItemsPerCustomerWithOptions(sessionId, customerId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The default currency is referenced by a configuration variable called DEFAULT_CURRENCY. If
     * this isn't found then we return the currency in the currency table with the lowest id.
     * 
     * @return Returns a currency object
     * @throws KKException
     */
     public CurrencyIf getDefaultCurrency() throws KKException
     {
         try
         {
            if (_getDefaultCurrency == null)
            {
                _getDefaultCurrency = new GetDefaultCurrency(kkEng);
            }

            return _getDefaultCurrency.getDefaultCurrency();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of currency objects for all the records in the currencies table.
     * 
     * @return Returns an array of currency objects
     * @throws KKException
     */
     public CurrencyIf[] getAllCurrencies() throws KKException
     {
         try
         {
            if (_getAllCurrencies == null)
            {
                _getAllCurrencies = new GetAllCurrencies(kkEng);
            }

            return _getAllCurrencies.getAllCurrencies();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Configuration objects containing all configurations that have been
     * defined in the system and that have been defined to be returned via the API.
     * 
     * @return An array of Configuration objects.
     * @throws KKException
     */
     public KKConfigurationIf[] getConfigurations() throws KKException
     {
         try
         {
            if (_getConfigurations == null)
            {
                _getConfigurations = new GetConfigurations(kkEng);
            }

            return _getConfigurations.getConfigurations();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration object referenced by the key passed in as a parameter. Note that a
     * KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            The key of the configuration object
     * @return A Configuration object
     * @throws KKException
     */
     public KKConfigurationIf getConfiguration(String key) throws KKException
     {
         try
         {
            if (_getConfiguration == null)
            {
                _getConfiguration = new GetConfiguration(kkEng);
            }

            return _getConfiguration.getConfiguration(key);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value referenced by the key passed in as a parameter. Note that a
     * KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            The key of the configuration object
     * @return A Configuration Value or null if the key does not exist
     * @throws KKException
     */
     public String getConfigurationValue(String key) throws KKException
     {
         try
         {
            if (_getConfigurationValue == null)
            {
                _getConfigurationValue = new GetConfigurationValue(kkEng);
            }

            return _getConfigurationValue.getConfigurationValue(key);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value as an integer for the key passed in as a parameter. Note that a
     * KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            the Configuration Key
     * @return A Configuration Value as an integer or KKConstants.NOT_SET if the key isn't found.
     * @throws KKException
     *             if there is a problem converting the configuration value into an integer.
     */
     public int getConfigurationValueAsInt(String key) throws KKException
     {
         try
         {
            if (_getConfigurationValueAsInt == null)
            {
                _getConfigurationValueAsInt = new GetConfigurationValueAsInt(kkEng);
            }

            return _getConfigurationValueAsInt.getConfigurationValueAsInt(key);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value as an integer for the key passed in as a parameter. Note that a
     * KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            the Configuration Key
     * @param def
     *            default value to return if the key isn't found.
     * @return A Configuration Value as an integer or the default value if the key isn't found.
     * @throws KKException
     *             if there is a problem converting the configuration value into an integer.
     */
     public int getConfigurationValueAsIntWithDefault(String key, int def) throws KKException
     {
         try
         {
            if (_getConfigurationValueAsIntWithDefault == null)
            {
                _getConfigurationValueAsIntWithDefault = new GetConfigurationValueAsIntWithDefault(kkEng);
            }

            return _getConfigurationValueAsIntWithDefault.getConfigurationValueAsIntWithDefault(key, def);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value as a BigDecimal for the key passed in as a parameter. Note that
     * a KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            the Configuration Key
     * @return A Configuration Value as a BigDecimal or null if the key isn't found.
     * @throws KKException
     *             if there is a problem converting the configuration value into a BigDecimal.
     */
     public BigDecimal getConfigurationValueAsBigDecimal(String key) throws KKException
     {
         try
         {
            if (_getConfigurationValueAsBigDecimal == null)
            {
                _getConfigurationValueAsBigDecimal = new GetConfigurationValueAsBigDecimal(kkEng);
            }

            return _getConfigurationValueAsBigDecimal.getConfigurationValueAsBigDecimal(key);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value as a BigDecimal for the key passed in as a parameter. Note that
     * a KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            the Configuration Key
     * @param def
     *            default value to use if the key doesn't exist.
     * @return A Configuration Value as a BigDecimal or the default value if the key isn't found.
     * @throws KKException
     *             if there is a problem converting the configuration value into a BigDecimal.
     */
     public BigDecimal getConfigurationValueAsBigDecimalWithDefault(String key, BigDecimal def) throws KKException
     {
         try
         {
            if (_getConfigurationValueAsBigDecimalWithDefault == null)
            {
                _getConfigurationValueAsBigDecimalWithDefault = new GetConfigurationValueAsBigDecimalWithDefault(kkEng);
            }

            return _getConfigurationValueAsBigDecimalWithDefault.getConfigurationValueAsBigDecimalWithDefault(key, def);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Configuration Value as a Boolean for the key passed in as a parameter. Note that a
     * KKException will be thrown if the configuration key requested has not been marked to be
     * returned by the APIs.
     * 
     * @param key
     *            the Configuration Key
     * @param def
     *            the default value to be returned if there's a problem
     * @return A Configuration Value as a Boolean or the default value if the key isn't found.
     * @throws KKException
     */
     public Boolean getConfigurationValueAsBool(String key, Boolean def) throws KKException
     {
         try
         {
            if (_getConfigurationValueAsBool == null)
            {
                _getConfigurationValueAsBool = new GetConfigurationValueAsBool(kkEng);
            }

            return _getConfigurationValueAsBool.getConfigurationValueAsBool(key, def);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This API has been deprecated and throws a KKException in all cases. Configuration values will
     * no longer be modified using this call.
     * <p>
     * Previously this call allowed the edit of an existing configuration parameter. It threw an
     * exception if the configuration didn't exist.
     * 
     * @deprecated From version 6.3.0.0 you should use the Administration APIs (KKAdminIf) instead.
     * @param key
     *            The key of the configuration object
     * @param value
     *            The new value for the configuration
     * @throws KKException
     *             in all cases warning that the API call should no longer be used.
     */
    @Deprecated
     public void editConfiguration(String key, String value) throws KKException
     {
         try
         {
            if (_editConfiguration == null)
            {
                _editConfiguration = new EditConfiguration(kkEng);
            }

            _editConfiguration.editConfiguration(key, value);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Ensures that the current password is correct, and then changes it to the new password. It
     * allows any password length and relies on the application to ensure that a minimum length is
     * guaranteed. Throws an exception if the currentPassword doesn't match.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param currentPassword
     *            The current password of the logged in user
     * @param newPassword
     *            The new password of the logged in user
     * @throws KKException
     */
     public void changePassword(String sessionId, String currentPassword, String newPassword) throws KKException
     {
         try
         {
            if (_changePassword == null)
            {
                _changePassword = new ChangePassword(kkEng);
            }

            _changePassword.changePassword(sessionId, currentPassword, newPassword);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns all products sorted by name, that the customer has asked to be notified about. An
     * exception is thrown if the <code>sessionId</code> isn't valid.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns a Product array
     * @throws KKException
     */
     public ProductIf[] getProductNotificationsPerCustomer(String sessionId, int languageId) throws KKException
     {
         try
         {
            if (_getProductNotificationsPerCustomer == null)
            {
                _getProductNotificationsPerCustomer = new GetProductNotificationsPerCustomer(kkEng);
            }

            return _getProductNotificationsPerCustomer.getProductNotificationsPerCustomer(sessionId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getProductNotificationsPerCustomer().
     * <p>
     * Returns all products sorted by name, that the customer has asked to be notified about. An
     * exception is thrown if the <code>sessionId</code> isn't valid.
     * <p>
     * Only Products with a non zero status and non zero invisible are returned. The description
     * (which can be very long) and the array of options are not set. The specialPrice is null if a
     * special offer doesn't exist for the product.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Product array
     * @throws KKException
     */
     public ProductIf[] getProductNotificationsPerCustomerWithOptions(String sessionId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductNotificationsPerCustomerWithOptions == null)
            {
                _getProductNotificationsPerCustomerWithOptions = new GetProductNotificationsPerCustomerWithOptions(kkEng);
            }

            return _getProductNotificationsPerCustomerWithOptions.getProductNotificationsPerCustomerWithOptions(sessionId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Adds a product notification to the list of notifications for the customer. An exception is
     * thrown if the <code>sessionId</code> isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param productId
     *            The numeric id of the product
     * @throws KKException
     */
     public void addProductNotificationToCustomer(String sessionId, int productId) throws KKException
     {
         try
         {
            if (_addProductNotificationToCustomer == null)
            {
                _addProductNotificationToCustomer = new AddProductNotificationToCustomer(kkEng);
            }

            _addProductNotificationToCustomer.addProductNotificationToCustomer(sessionId, productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Deletes a product notification from the list of notifications for the customer. An exception
     * is thrown if the <code>sessionId</code> isn't valid.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param productId
     *            The numeric id of the product
     * @throws KKException
     */
     public void deleteProductNotificationFromCustomer(String sessionId, int productId) throws KKException
     {
         try
         {
            if (_deleteProductNotificationFromCustomer == null)
            {
                _deleteProductNotificationFromCustomer = new DeleteProductNotificationFromCustomer(kkEng);
            }

            _deleteProductNotificationFromCustomer.deleteProductNotificationFromCustomer(sessionId, productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * It updates the number of times that the product referenced by <code>productId</code>, has
     * been viewed. The <code>languageId</code> is required because a separate count is kept for how
     * many times the product has been viewed in each supported language.
     * 
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @throws KKException
     */
     public void updateProductViewedCount(int productId, int languageId) throws KKException
     {
         try
         {
            if (_updateProductViewedCount == null)
            {
                _updateProductViewedCount = new UpdateProductViewedCount(kkEng);
            }

            _updateProductViewedCount.updateProductViewedCount(productId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of bestseller products for the category referenced by
     * <code>categoryId</code> and its children. The products are returned in the language
     * referenced by <code>languageId</code>. If the <code>categoryId</code> is equal to 0, then it
     * is not used as a constraint for the query.
     * <p>
     * <code>dataDesc</code> defines the ordering of the products and the number of products
     * returned.
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return An array of products
     * @throws KKException
     */
     public ProductIf[] getBestSellers(DataDescriptorIf dataDesc, int categoryId, int languageId) throws KKException
     {
         try
         {
            if (_getBestSellers == null)
            {
                _getBestSellers = new GetBestSellers(kkEng);
            }

            return _getBestSellers.getBestSellers(dataDesc, categoryId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getBestSellers().
     * <p>
     * Returns an array of bestseller products for the category referenced by
     * <code>categoryId</code> and its children. The products are returned in the language
     * referenced by <code>languageId</code>. If the <code>categoryId</code> is equal to 0, then it
     * is not used as a constraint for the query.
     * <p>
     * <code>dataDesc</code> defines the ordering of the products and the number of products
     * returned.
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return An array of products
     * @throws KKException
     */
     public ProductIf[] getBestSellersWithOptions(DataDescriptorIf dataDesc, int categoryId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBestSellersWithOptions == null)
            {
                _getBestSellersWithOptions = new GetBestSellersWithOptions(kkEng);
            }

            return _getBestSellersWithOptions.getBestSellersWithOptions(dataDesc, categoryId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieve a number of orders for the customer referenced by the <code>sessionId</code>. The
     * orders are always returned sorted by date (most recent orders first). <code>dataDesc</code>
     * is used to retrieve offset and limit information. If null, the offset defaults to 0 and a
     * default limit is used.
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return An Orders object
     * @throws KKException
     */
     public OrdersIf getOrdersPerCustomer(DataDescriptorIf dataDesc, String sessionId, int languageId) throws KKException
     {
         try
         {
            if (_getOrdersPerCustomer == null)
            {
                _getOrdersPerCustomer = new GetOrdersPerCustomer(kkEng);
            }

            return _getOrdersPerCustomer.getOrdersPerCustomer(dataDesc, sessionId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieve a number of orders for the customer referenced by the <code>sessionId</code> for the
     * given language. The OrderSearch class contains the search criteria although it may be null.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved orders is limited to
     * a default number, the orders are ordered by the OrderId and the offset is set to zero.
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of Order objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Order objects, in
     * order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only orders with a
     * matching custom attribute value are returned.</li>
     * <li>The Orders may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ORDER_NUMBER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ORDER_NUMBER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param orderSearch
     *            Contains information used to add search constraints
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return An Orders object
     * @throws KKException
     */
     public OrdersIf searchForOrdersPerCustomer(String sessionId, DataDescriptorIf dataDesc, OrderSearchIf orderSearch, int languageId) throws KKException
     {
         try
         {
            if (_searchForOrdersPerCustomer == null)
            {
                _searchForOrdersPerCustomer = new SearchForOrdersPerCustomer(kkEng);
            }

            return _searchForOrdersPerCustomer.searchForOrdersPerCustomer(sessionId, dataDesc, orderSearch, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets on order with the specified order Id, for the customer referenced by the
     * <code>sessionId</code>.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return An order object
     * @throws KKException
     */
     public OrderIf getOrder(String sessionId, int orderId, int languageId) throws KKException
     {
         try
         {
            if (_getOrder == null)
            {
                _getOrder = new GetOrder(kkEng);
            }

            return _getOrder.getOrder(sessionId, orderId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the currency referenced by <code>currencyCode</code>.
     * 
     * @param currencyCode
     *            The 3 letter currency code (i.e. USD, EUR ..)
     * @return Returns a currency object
     * @throws KKException
     */
     public CurrencyIf getCurrency(String currencyCode) throws KKException
     {
         try
         {
            if (_getCurrency == null)
            {
                _getCurrency = new GetCurrency(kkEng);
            }

            return _getCurrency.getCurrency(currencyCode);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An order object is returned with all addresses populated with the default address of the
     * customer referenced by <code>sessionId</code>. The products added to the order are retrieved
     * from the basketItemArray. Each OrderProduct object attached to the Order has a populated
     * Product object. The returned object has not been saved in the DB and so an Order Id has not
     * yet been assigned.
     * <p>
     * Null is returned if the products and/or product options referenced by the array of basket
     * items are no longer available.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param basketItemArray
     *            The array of basket items to add to the order
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Order object
     * @throws KKException
     */
     public OrderIf createOrder(String sessionId, BasketIf[] basketItemArray, int languageId) throws KKException
     {
         try
         {
            if (_createOrder == null)
            {
                _createOrder = new CreateOrder(kkEng);
            }

            return _createOrder.createOrder(sessionId, basketItemArray, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If <code>options</code> is set to null, this method is identical to
     * <code>createOrder()</code>. Otherwise the functionality differs depending on the combination
     * of options set.
     * <p>
     * An order object is returned with all addresses populated with the default address of the
     * customer referenced by <code>sessionId</code>. The products added to the order are retrieved
     * from the basketItemArray. The returned object has not been saved in the DB and so an Order Id
     * has not yet been assigned.
     * <p>
     * Null is returned if the products and/or product options referenced by the array of basket
     * items are no longer available.
     * <p>
     * One available option is to automatically copy all of the <code>basket</code> custom fields to
     * the <code>orderProduct</code> custom fields which are generated from the basket items.
     * <p>
     * Another option allows you to leave the sessionId null and to use a default customer. This
     * default customer needs to be setup using the Admin App and is used to create a temporary
     * order even before the customer logs in or registers, so that he can view the order totals in
     * the window that shows him the cart details. These order totals give an indication of the
     * shipping cost and also show any discounts available. The Administrator can create a default
     * customer that matches his typical customer. For example if a store normally ships overseas,
     * then the default customer can be set up with an overseas address so that the shipping costs
     * are calculated at overseas rates.
     * <p>
     * A further option is to use the shipping address retrieved from a wish list if the wish list
     * id of any one of the basket items is set to a valid wish list. This is useful in the case of
     * gift registries to ship the gifts directly to the owner of the registry.
     * <p>
     * The <code>options</code> object contains a number of attributes to control whether the
     * returned order includes an array of available payment modules and shipping quotes and if so
     * which one to use as the selected module or quote. The population of order total modules may
     * also be enabled. The Javadoc of <code>CreateOrderOptionsIf</code> provides more details.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param basketItemArray
     *            The array of basket items to add to the order
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Order object
     * @throws KKException
     */
     public OrderIf createOrderWithOptions(String sessionId, BasketIf[] basketItemArray, CreateOrderOptionsIf options, int languageId) throws KKException
     {
         try
         {
            if (_createOrderWithOptions == null)
            {
                _createOrderWithOptions = new CreateOrderWithOptions(kkEng);
            }

            return _createOrderWithOptions.createOrderWithOptions(sessionId, basketItemArray, options, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get a list of the products ordered by the customer referenced by <code>sessionId</code>. The
     * number of products returned and the return order is determined by the <code>dataDesc</code>
     * parameter. The default OrderBy is "ORDER_BY_NAME_ASCENDING".
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an array of products
     * @throws KKException
     */
     public ProductIf[] getOrderHistory(DataDescriptorIf dataDesc, String sessionId, int languageId) throws KKException
     {
         try
         {
            if (_getOrderHistory == null)
            {
                _getOrderHistory = new GetOrderHistory(kkEng);
            }

            return _getOrderHistory.getOrderHistory(dataDesc, sessionId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getOrderHistory().
     * <p>
     * Get a list of the products ordered by the customer referenced by <code>sessionId</code>. The
     * number of products returned and the return order is determined by the <code>dataDesc</code>
     * parameter. The default OrderBy is "ORDER_BY_NAME_ASCENDING".
     * 
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of products
     * @throws KKException
     */
     public ProductIf[] getOrderHistoryWithOptions(DataDescriptorIf dataDesc, String sessionId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getOrderHistoryWithOptions == null)
            {
                _getOrderHistoryWithOptions = new GetOrderHistoryWithOptions(kkEng);
            }

            return _getOrderHistoryWithOptions.getOrderHistoryWithOptions(dataDesc, sessionId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Find products that were in the same order as orders containing the product referenced by
     * <code>productId</code>. The return order of the products is by purchase date.
     * <code>dataDesc</code> determines the number of products returned.
     * <p>
     * <code>sessionId</code> may be set to null. If it is valid, then the customer information is
     * used to calculate the tax. Otherwise the store location is used.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an array of products
     * @throws KKException
     */
     public ProductIf[] getAlsoPurchased(String sessionId, DataDescriptorIf dataDesc, int productId, int languageId) throws KKException
     {
         try
         {
            if (_getAlsoPurchased == null)
            {
                _getAlsoPurchased = new GetAlsoPurchased(kkEng);
            }

            return _getAlsoPurchased.getAlsoPurchased(sessionId, dataDesc, productId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getAlsoPurchased().
     * <p>
     * Find products that were in the same order as orders containing the product referenced by
     * <code>productId</code>. The return order of the products is by purchase date.
     * <code>dataDesc</code> determines the number of products returned.
     * <p>
     * <code>sessionId</code> may be set to null. If it is valid, then the customer information is
     * used to calculate the tax. Otherwise the store location is used.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of products
     * @throws KKException
     */
     public ProductIf[] getAlsoPurchasedWithOptions(String sessionId, DataDescriptorIf dataDesc, int productId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getAlsoPurchasedWithOptions == null)
            {
                _getAlsoPurchasedWithOptions = new GetAlsoPurchasedWithOptions(kkEng);
            }

            return _getAlsoPurchasedWithOptions.getAlsoPurchasedWithOptions(sessionId, dataDesc, productId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Find products related to the product defined by the <code>productId</code> parameter.
     * <p>
     * The <code>relationType</code> defines the relation. Valid values for
     * <code>relationType</code> are:
     * <ul>
     * <li>com.konakart.bl.ProductMgr.ALL_RELATIONSHIPS: All relationships. Returns all related
     * products.</li>
     * <li>com.konakart.bl.ProductMgr.UP_SELL: Up Selling. Normally a superior version of the same
     * product.</li>
     * <li>com.konakart.bl.ProductMgr.CROSS_SELL: Cross Selling. Normally similar or related
     * products.</li>
     * <li>com.konakart.bl.ProductMgr.ACCESSORY: Accessories</li>
     * <li>com.konakart.bl.ProductMgr.DEPENDENT_ITEM: Dependent Item. Normally cannot be sold
     * independently such as a warranty.</li>
     * <li>com.konakart.bl.ProductMgr.BUNDLED_PRODUCT_RELATIONSHIP: This relationship can be used
     * when productId is the id of a "bundle" product. It returns all products that are part of the
     * bundle.</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_1: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_2: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_3: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_4: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_5: Custom Relationship</li>
     * </ul>
     * <p>
     * When all relationships are returned by setting <code>relationType</code> to 0, the
     * <code>prodRelationType</code> attribute of the returned products is set, so that the
     * information about the type of relationship is not lost.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order. It may be null, in which case the number of retrieved products is
     *            limited to a default number and the offset is set to zero.
     * @param productId
     *            The numeric id of the product
     * @param relationType
     *            The numeric relation type defining up selling, cross selling etc.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Array of products
     * @throws KKException
     */
     public ProductsIf getRelatedProducts(String sessionId, DataDescriptorIf dataDesc, int productId, int relationType, int languageId) throws KKException
     {
         try
         {
            if (_getRelatedProducts == null)
            {
                _getRelatedProducts = new GetRelatedProducts(kkEng);
            }

            return _getRelatedProducts.getRelatedProducts(sessionId, dataDesc, productId, relationType, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An options object is passed in to customize from where some of the product attributes (such
     * as price and quantity) are fetched from. If options is set to null, then this call is
     * identical to getRelatedProducts().
     * <p>
     * Find products related to the product defined by the <code>productId</code> parameter. The
     * <code>relationType</code> defines the relation. Valid values for <code>relationType</code>
     * are:
     * <ul>
     * <li>com.konakart.bl.ProductMgr.ALL_RELATIONSHIPS: All relationships. Returns all related
     * products.</li>
     * <li>com.konakart.bl.ProductMgr.UP_SELL: Up Selling. Normally a superior version of the same
     * product.</li>
     * <li>com.konakart.bl.ProductMgr.CROSS_SELL: Cross Selling. Normally similar or related
     * products.</li>
     * <li>com.konakart.bl.ProductMgr.ACCESSORY: Accessories</li>
     * <li>com.konakart.bl.ProductMgr.DEPENDENT_ITEM: Dependent Item. Normally cannot be sold
     * independently such as a warranty.</li>
     * <li>com.konakart.bl.ProductMgr.BUNDLED_PRODUCT_RELATIONSHIP: This relationship can be used
     * when productId is the id of a "bundle" product. It returns all products that are part of the
     * bundle.</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_1: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_2: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_3: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_4: Custom Relationship</li>
     * <li>com.konakart.bl.ProductMgr.CUSTOM_RELATIONSHIP_5: Custom Relationship</li>
     * </ul>
     * <p>
     * When all relationships are returned by setting <code>relationType</code> to 0, the
     * <code>prodRelationType</code> attribute of the returned products is set, so that the
     * information about the type of relationship is not lost.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order. It may be null, in which case the number of retrieved products is
     *            limited to a default number and the offset is set to zero.
     * @param productId
     *            The numeric id of the product
     * @param relationType
     *            The numeric relation type defining up selling, cross selling etc.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null. This object
     *            contains an attribute called <code>invertRelatedProductDirection</code> which If
     *            true, inverts the direction of the related product link. This is especially useful
     *            for bundled products, so rather than discovering the products within a bundle, you
     *            can determine which bundles a product belongs to by setting this attribute to
     *            true.
     * @return Array of products
     * @throws KKException
     */
     public ProductsIf getRelatedProductsWithOptions(String sessionId, DataDescriptorIf dataDesc, int productId, int relationType, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getRelatedProductsWithOptions == null)
            {
                _getRelatedProductsWithOptions = new GetRelatedProductsWithOptions(kkEng);
            }

            return _getRelatedProductsWithOptions.getRelatedProductsWithOptions(sessionId, dataDesc, productId, relationType, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the country object for the <code>countryName</code>, or null if the country doesn't
     * exist in the DB. If there is more than one country with the same name, we return the first
     * one that we find.
     * 
     * @param countryName
     *            The name of the country
     * @return Returns a country object
     * @throws KKException
     */
     public CountryIf getCountryPerName(String countryName) throws KKException
     {
         try
         {
            if (_getCountryPerName == null)
            {
                _getCountryPerName = new GetCountryPerName(kkEng);
            }

            return _getCountryPerName.getCountryPerName(countryName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the country object for the <code>countryId</code>, or null if the country doesn't
     * exist in the DB.
     * 
     * @param countryId
     *            The id of the country object
     * @return Returns a country object
     * @throws KKException
     */
     public CountryIf getCountry(int countryId) throws KKException
     {
         try
         {
            if (_getCountry == null)
            {
                _getCountry = new GetCountry(kkEng);
            }

            return _getCountry.getCountry(countryId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * All active installed shipping modules are called in order to get an array of shipping quotes.
     * This is normally called to display a selection of quotes to the customer during the checkout
     * process.
     * 
     * @param order
     *            The order object
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an array of shipping quotes
     * @throws KKException
     */
     public ShippingQuoteIf[] getShippingQuotes(OrderIf order, int languageId) throws KKException
     {
         try
         {
            if (_getShippingQuotes == null)
            {
                _getShippingQuotes = new GetShippingQuotes(kkEng);
            }

            return _getShippingQuotes.getShippingQuotes(order, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The shipping module called <code>moduleName</code> is called to get a shipping quote for the
     * order passed in as a parameter. Null is returned if the shipping module isn't available.
     * 
     * @param order
     *            The order object
     * @param moduleName
     *            e.g. flat or item or table etc.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Return a shipping quote
     * @throws KKException
     */
     public ShippingQuoteIf getShippingQuote(OrderIf order, String moduleName, int languageId) throws KKException
     {
         try
         {
            if (_getShippingQuote == null)
            {
                _getShippingQuote = new GetShippingQuote(kkEng);
            }

            return _getShippingQuote.getShippingQuote(order, moduleName, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The delivery address of the order is changed and the tax rates for the various products
     * within the order are re-calculated.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param order
     *            The order object
     * @param deliveryAddress
     *            The address object containing the delivery address
     * @return Returns an order with modified delivery address
     * @throws KKException
     */
     public OrderIf changeDeliveryAddress(String sessionId, OrderIf order, AddressIf deliveryAddress) throws KKException
     {
         try
         {
            if (_changeDeliveryAddress == null)
            {
                _changeDeliveryAddress = new ChangeDeliveryAddress(kkEng);
            }

            return _changeDeliveryAddress.changeDeliveryAddress(sessionId, order, deliveryAddress);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Calculates the tax rate for a product with a <code>taxClassId</code> delivered to a country (
     * <code>countryId</code>) and zone (<code>zoneId</code>). There may be multiple tax rates which
     * are added and / or compounded as appropriate.
     * 
     * @param countryId
     *            The numeric id of the country
     * @param zoneId
     *            The numeric id of the zone
     * @param taxClassId
     *            The numeric id of the taxClass
     * @return Returns the tax rate
     * @throws KKException
     */
     public BigDecimal getTaxRate(int countryId, int zoneId, int taxClassId) throws KKException
     {
         try
         {
            if (_getTaxRate == null)
            {
                _getTaxRate = new GetTaxRate(kkEng);
            }

            return _getTaxRate.getTaxRate(countryId, zoneId, taxClassId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Calculates the tax for a product with a <code>taxClassId</code> and <code>cost</code>,
     * delivered to a country (<code>countryId</code>) and zone (<code>zoneId</code>).
     * 
     * @param cost
     *            The cost of the product
     * @param countryId
     *            The numeric id of the country
     * @param zoneId
     *            The numeric id of the zone
     * @param taxClassId
     *            The numeric id of the taxClass
     * @return Returns the tax amount
     * @throws KKException
     */
     public BigDecimal getTax(BigDecimal cost, int countryId, int zoneId, int taxClassId) throws KKException
     {
         try
         {
            if (_getTax == null)
            {
                _getTax = new GetTax(kkEng);
            }

            return _getTax.getTax(cost, countryId, zoneId, taxClassId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Calculates the final cost (including tax) for a product with a certain
     * <code>taxClassId</code> and <code>cost</code>, delivered to a country (<code>countryId</code>
     * ) and zone (<code>zoneId</code>).
     * 
     * @param cost
     *            The cost of the product
     * @param countryId
     *            The numeric id of the country
     * @param zoneId
     *            The numeric id of the zone
     * @param taxClassId
     *            The numeric id of the taxClass
     * @return Returns the cost inclusive of tax
     * @throws KKException
     */
     public BigDecimal addTax(BigDecimal cost, int countryId, int zoneId, int taxClassId) throws KKException
     {
         try
         {
            if (_addTax == null)
            {
                _addTax = new AddTax(kkEng);
            }

            return _addTax.addTax(cost, countryId, zoneId, taxClassId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The order object is populated with an array of order totals. The order totals depend on the
     * order total modules installed.
     * 
     * @param order
     *            The order object
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return An order object
     * @throws KKException
     */
     public OrderIf getOrderTotals(OrderIf order, int languageId) throws KKException
     {
         try
         {
            if (_getOrderTotals == null)
            {
                _getOrderTotals = new GetOrderTotals(kkEng);
            }

            return _getOrderTotals.getOrderTotals(order, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Each payment module is called and asked to return a PaymentDetails object. This method is
     * called during the checkout process before the order has been saved and confirmed by the user.
     * Therefore it does not compile the exact details for the payment (i.e. the parameters passed
     * to a payment gateway) since this will be done later for the selected payment module. The
     * returned PaymentDetails object contains the information required for the user to select it.
     * <p>
     * Based on the zone of the billing address, the module may decide that it cannot process
     * payment for that zone and so not even return a PaymentDetails object.
     * 
     * @param order
     *            The order object
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Return an array of PaymentDetails objects
     * @throws KKException
     */
     public PaymentDetailsIf[] getPaymentGateways(OrderIf order, int languageId) throws KKException
     {
         try
         {
            if (_getPaymentGateways == null)
            {
                _getPaymentGateways = new GetPaymentGateways(kkEng);
            }

            return _getPaymentGateways.getPaymentGateways(order, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The payment module called <code>moduleName</code> is called to get a PaymentDetails object
     * for the order passed in as a parameter. Null is returned if the PaymentDetails object isn't
     * available.
     * <p>
     * Based on the zone of the billing address, the module may decide that it cannot process
     * payment for that zone and so in this case, null is returned.
     * 
     * @param order
     *            The order object
     * @param moduleName
     *            This is the name of the payment module. The name must match the class name except
     *            that the first letter doesn't have to be in Caps. e.g. CyberSourceSA,
     *            CommideaVanguard, authorizenet, BarclaycardSmartPayApi etc. The moduleName can be
     *            the module name on its own or it can be "moduleName~~moduleSubCode" if the module
     *            has a subCode.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Return a PaymentDetails object
     * @throws KKException
     */
     public PaymentDetailsIf getPaymentGateway(OrderIf order, String moduleName, int languageId) throws KKException
     {
         try
         {
            if (_getPaymentGateway == null)
            {
                _getPaymentGateway = new GetPaymentGateway(kkEng);
            }

            return _getPaymentGateway.getPaymentGateway(order, moduleName, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is called once a payment gateway has been selected and an order has been saved in
     * the database. The order is read from the database and the details of the payment are
     * retrieved from the order. This ensures that the payment request matches the order exactly.
     * <p>
     * The module matching the <code>moduleCode</code> is called in order to get a fully populated
     * PaymentDetails object containing all of the required parameters etc. for the payment gateway.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param moduleCode
     *            This is the name of the payment module in lower case. Examples are cod, paypal,
     *            usaepay, worldpay etc.
     * @param orderId
     *            The numeric id of the order
     * @param hostAndPort
     *            The host and port in the format "host:port" for the KonaKart servlet engine.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Return a PaymentDetails object
     * @throws KKException
     */
     public PaymentDetailsIf getPaymentDetails(String sessionId, String moduleCode, int orderId, String hostAndPort, int languageId) throws KKException
     {
         try
         {
            if (_getPaymentDetails == null)
            {
                _getPaymentDetails = new GetPaymentDetails(kkEng);
            }

            return _getPaymentDetails.getPaymentDetails(sessionId, moduleCode, orderId, hostAndPort, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is called once a payment gateway has been selected even if the order has not been
     * saved in the database. The details of the payment are retrieved from the order.
     * <p>
     * The module matching the <code>moduleCode</code> is called in order to get a fully populated
     * PaymentDetails object containing all of the required parameters etc. for the payment gateway.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param moduleCode
     *            This is the name of the payment module in lower case. Examples are cod, paypal,
     *            usaepay, worldpay etc.
     * @param order
     *            The order object
     * @param hostAndPort
     *            The host and port in the format "host:port" for the KonaKart servlet engine.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Return a PaymentDetails object
     * @throws KKException
     */
     public PaymentDetailsIf getPaymentDetailsPerOrder(String sessionId, String moduleCode, OrderIf order, String hostAndPort, int languageId) throws KKException
     {
         try
         {
            if (_getPaymentDetailsPerOrder == null)
            {
                _getPaymentDetailsPerOrder = new GetPaymentDetailsPerOrder(kkEng);
            }

            return _getPaymentDetailsPerOrder.getPaymentDetailsPerOrder(sessionId, moduleCode, order, hostAndPort, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Method used to return any custom information required from the payment module.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param moduleCode
     *            This is the name of the payment module in lower case. Examples are cod, paypal,
     *            usaepay, worldpay etc.
     * @param parameters
     *            An array of parameters used by the payment module to determine what it needs to
     *            return.
     * @return Return a PaymentDetails object
     * @throws KKException
     */
     public PaymentDetailsIf getPaymentDetailsCustom(String sessionId, String moduleCode, NameValueIf[] parameters) throws KKException
     {
         try
         {
            if (_getPaymentDetailsCustom == null)
            {
                _getPaymentDetailsCustom = new GetPaymentDetailsCustom(kkEng);
            }

            return _getPaymentDetailsCustom.getPaymentDetailsCustom(sessionId, moduleCode, parameters);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A new order is created in the DB. The Order object parameter should have all addresses
     * populated (customer, billing and delivery). The status of the newly created order is taken
     * from the order itself. A check is made to determine whether the status exists within the
     * orders_status table.
     * <p>
     * To save an order we have to write into a few DB tables: orders, orders_products,
     * orders_products_attributes, orders_total, orders_status_history. We do this in a single
     * transaction.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param order
     *            The order object
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns the order id
     * @throws KKException
     */
     public int saveOrder(String sessionId, OrderIf order, int languageId) throws KKException
     {
         try
         {
            if (_saveOrder == null)
            {
                _saveOrder = new SaveOrder(kkEng);
            }

            return _saveOrder.saveOrder(sessionId, order, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the text of a status from the orders_status table. This table contains order status
     * descriptions in different languages.
     * 
     * @param statusId
     *            The numeric id of the OrderStatus object
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns the text of the status. Returns Null if not found.
     * @throws KKException
     */
     public String getStatusText(int statusId, int languageId) throws KKException
     {
         try
         {
            if (_getStatusText == null)
            {
                _getStatusText = new GetStatusText(kkEng);
            }

            return _getStatusText.getStatusText(statusId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The state of the order referenced by the orderId parameter is changed, and an
     * orders_status_history record is added to the order to keep track of the change.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param status
     *            The new numeric state of the order. Valid states are defined in the database.
     * @param customerNotified
     *            If you send an eMail to the customer to notify him of the state change then set
     *            this to true to register the fact that an eMail has been sent
     * @param comments
     *            These comments are written into the orders_status_history record
     * @param updateOrder
     *            contains order update data such as who updated the order
     * @throws KKException
     */
     public void updateOrder(String sessionId, int orderId, int status, boolean customerNotified, String comments, OrderUpdateIf updateOrder) throws KKException
     {
         try
         {
            if (_updateOrder == null)
            {
                _updateOrder = new UpdateOrder(kkEng);
            }

            _updateOrder.updateOrder(sessionId, orderId, status, customerNotified, comments, updateOrder);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The state of the order referenced by the orderId parameter is changed, and an
     * orders_status_history record is added to the order to keep track of the change.
     * 
     * @deprecated From version 6.2.0.0 you should use {@link #updateOrder} instead.
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param status
     *            The new numeric state of the order. Valid states are defined in the database.
     * @param customerNotified
     *            If you send an eMail to the customer to notify him of the state change then set
     *            this to true to register the fact that an eMail has been sent
     * @param comments
     *            These comments are written into the orders_status_history record
     * @throws KKException
     */
    @Deprecated
     public void changeOrderStatus(String sessionId, int orderId, int status, boolean customerNotified, String comments) throws KKException
     {
         try
         {
            if (_changeOrderStatus == null)
            {
                _changeOrderStatus = new ChangeOrderStatus(kkEng);
            }

            _changeOrderStatus.changeOrderStatus(sessionId, orderId, status, customerNotified, comments);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If the STOCK_LIMITED configuration variable is set to true, we subtract the products in stock
     * by the product orders. If we hit the STOCK_REORDER_LEVEL, then we instantiate a class defined
     * by the STOCK_REORDER_CLASS and call it. If STOCK_ALLOW_CHECKOUT is set to true, when we hit
     * zero items in stock we don't touch the status, otherwise we disable the product when the
     * quantity reaches zero by setting the status to zero.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @throws KKException
     */
     public void updateInventory(String sessionId, int orderId) throws KKException
     {
         try
         {
            if (_updateInventory == null)
            {
                _updateInventory = new UpdateInventory(kkEng);
            }

            _updateInventory.updateInventory(sessionId, orderId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If <code>options</code> is set to null, this method is identical to
     * <code>updateInventory()</code>. Otherwise the functionality differs depending on the
     * combination of options set.
     * <p>
     * If the STOCK_LIMITED configuration variable is set to true, we subtract the products in stock
     * by the product orders. If we hit the STOCK_REORDER_LEVEL, then we instantiate a class defined
     * by the STOCK_REORDER_CLASS and call it. If STOCK_ALLOW_CHECKOUT is set to true, when we hit
     * zero items in stock we don't touch the status, otherwise we disable the product when the
     * quantity reaches zero by setting the status to zero.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void updateInventoryWithOptions(String sessionId, int orderId, CreateOrderOptionsIf options) throws KKException
     {
         try
         {
            if (_updateInventoryWithOptions == null)
            {
                _updateInventoryWithOptions = new UpdateInventoryWithOptions(kkEng);
            }

            _updateInventoryWithOptions.updateInventoryWithOptions(sessionId, orderId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A mail is sent to emailAddr containing a new password. The language of the email depends on
     * the two letter country code which is used to choose the correct template for creating the
     * mail.
     * 
     * @param emailAddr
     *            Address of the email
     * @param subject
     *            The email subject line. If null it is retrieved from the first line of the
     *            template.
     * @param countryCode
     *            Two letter code used to pick correct template
     * @throws KKException
     * @deprecated
     */
    @Deprecated
     public void sendNewPassword(String emailAddr, String subject, String countryCode) throws KKException
     {
         try
         {
            if (_sendNewPassword == null)
            {
                _sendNewPassword = new SendNewPassword(kkEng);
            }

            _sendNewPassword.sendNewPassword(emailAddr, subject, countryCode);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A mail is sent to emailAddr containing a new password.
     * <p>
     * Valid options are:
     * <ul>
     * <li><code>templateName</code>: The name of the template used to send the mail without the
     * country code and the .vm extension. e.g. If the name of the template is myTemplate and the
     * two letter country code is en, then KonaKart will search for a template called
     * myTemplate_en.vm .</li>
     * <li><code>countryCode</code>: The two letter (lower case) country code used to search for the
     * template. e.g. en, de, es etc.</li>
     * <li><code>customAttrs</code>: An array of name value pairs used to pass custom information to
     * the Velocity engine. The value can be retrieved from the template using the name preceded by
     * the $ sign. e.g. If a name value pair contains StoreId and 22, the value 22 will be displayed
     * in the eMail where the template contains $StoreId.</li>
     * <li><code>fullAttachmentFilename</code>: The complete filename of an attachment.</li>
     * <li><code>friendlyAttachmentName</code>: The friendly filename of an attachment that can be
     * viewed from the eMail.</li>
     * <li><code>deleteAttachmentAfterSend</code>: When set to <code>true</code>, the attachment is
     * deleted after being sent. The default value is <code>false</code>.</li>
     * </ul>
     * <p>
     * The Velocity context contains the following data:
     * <ul>
     * <li><code>emailAddr</code>: The email address of the recipient</li>
     * <li><code>newPassword</code>: The new password</li>
     * <li><code>customerName</code>: The name of the customer in the format firstName lastName</li>
     * <li><code>customer</code>: The CustomerIf object</li>
     * <li><code>storeOwner</code>: The name of the store owner.</li>
     * <li><code>storeName</code>: The name of the store.</li>
     * <li><code>storeOwnerEmailAddr</code>: The email address of the store owner.</li>
     * <li><code>dateTool</code>: org.apache.velocity.tools.generic.DateTool object used to format
     * dates.</li>
     * <li><code>locale</code>: java.util.Locale object</li>
     * <li><code>currencyMgr</code>: Used to format prices</li>
     * </ul>
     * 
     * @param emailAddr
     *            Address of the email
     * @param options
     *            Options for the email
     * @return Returns an Email object containing the content of the email
     * @throws KKException
     */
     public EmailIf sendNewPassword1(String emailAddr, EmailOptionsIf options) throws KKException
     {
         try
         {
            if (_sendNewPassword1 == null)
            {
                _sendNewPassword1 = new SendNewPassword1(kkEng);
            }

            return _sendNewPassword1.sendNewPassword1(emailAddr, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A welcome email is sent after registration of a new customer. The language of the email
     * depends on the two letter country code which is used to choose the correct template for
     * creating the mail.
     * 
     * @param customerId
     *            The numeric id of the customer
     * @param mailSubject
     *            The email subject line. If null it is retrieved from the first line of the
     *            template.
     * @param countryCode
     *            The two letter country code used to select the velocity template that creates the
     *            mail
     * @throws KKException
     * @deprecated
     */
    @Deprecated
     public void sendWelcomeEmail(int customerId, String mailSubject, String countryCode) throws KKException
     {
         try
         {
            if (_sendWelcomeEmail == null)
            {
                _sendWelcomeEmail = new SendWelcomeEmail(kkEng);
            }

            _sendWelcomeEmail.sendWelcomeEmail(customerId, mailSubject, countryCode);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A welcome email is sent after registration of a new customer.
     * <p>
     * Valid options are:
     * <ul>
     * <li><code>templateName</code>: The name of the template used to send the mail without the
     * country code and the .vm extension. e.g. If the name of the template is myTemplate and the
     * two letter country code is en, then KonaKart will search for a template called
     * myTemplate_en.vm .</li>
     * <li><code>countryCode</code>: The two letter (lower case) country code used to search for the
     * template. e.g. en, de, es etc.</li>
     * <li><code>customAttrs</code>: An array of name value pairs used to pass custom information to
     * the Velocity engine. The value can be retrieved from the template using the name preceded by
     * the $ sign. e.g. If a name value pair contains StoreId and 22, the value 22 will be displayed
     * in the eMail where the template contains $StoreId.</li>
     * <li><code>fullAttachmentFilename</code>: The complete filename of an attachment.</li>
     * <li><code>friendlyAttachmentName</code>: The friendly filename of an attachment that can be
     * viewed from the eMail.</li>
     * <li><code>deleteAttachmentAfterSend</code>: When set to <code>true</code>, the attachment is
     * deleted after being sent. The default value is <code>false</code>.</li>
     * </ul>
     * <p>
     * The Velocity context contains the following data:
     * <ul>
     * <li><code>customerName</code>: The name of the customer in the format firstName lastName</li>
     * <li><code>customer</code>: The CustomerIf object</li>
     * <li><code>storeOwner</code>: The name of the store owner.</li>
     * <li><code>storeName</code>: The name of the store.</li>
     * <li><code>storeOwnerEmailAddr</code>: The email address of the store owner.</li>
     * <li><code>dateTool</code>: org.apache.velocity.tools.generic.DateTool object used to format
     * dates.</li>
     * <li><code>locale</code>: java.util.Locale object</li>
     * <li><code>currencyMgr</code>: Used to format prices</li>
     * </ul>
     * 
     * @param customerId
     *            The numeric id of the customer
     * @param options
     *            Options for the email
     * @return Returns an Email object containing the content of the email
     * @throws KKException
     */
     public EmailIf sendWelcomeEmail1(int customerId, EmailOptionsIf options) throws KKException
     {
         try
         {
            if (_sendWelcomeEmail1 == null)
            {
                _sendWelcomeEmail1 = new SendWelcomeEmail1(kkEng);
            }

            return _sendWelcomeEmail1.sendWelcomeEmail1(customerId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A confirmation mail is sent after submitting an order. The language of the email depends on
     * the languageId which is used to choose the correct template for creating the mail.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param mailSubject
     *            The subject of the email
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @throws KKException
     * @deprecated
     */
    @Deprecated
     public void sendOrderConfirmationEmail(String sessionId, int orderId, String mailSubject, int languageId) throws KKException
     {
         try
         {
            if (_sendOrderConfirmationEmail == null)
            {
                _sendOrderConfirmationEmail = new SendOrderConfirmationEmail(kkEng);
            }

            _sendOrderConfirmationEmail.sendOrderConfirmationEmail(sessionId, orderId, mailSubject, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A confirmation mail is sent after submitting an order.
     * <p>
     * Valid options are:
     * <ul>
     * <li><code>templateName</code>: The name of the template used to send the mail without the
     * country code and the .vm extension. e.g. If the name of the template is myTemplate and the
     * two letter country code is en, then KonaKart will search for a template called
     * myTemplate_en.vm .</li>
     * <li><code>countryCode</code>: The two letter (lower case) country code used to search for the
     * template. e.g. en, de, es etc.</li>
     * <li><code>customAttrs</code>: An array of name value pairs used to pass custom information to
     * the Velocity engine. The value can be retrieved from the template using the name preceded by
     * the $ sign. e.g. If a name value pair contains StoreId and 22, the value 22 will be displayed
     * in the eMail where the template contains $StoreId.</li>
     * </ul>
     * <p>
     * The Velocity context contains the following data:
     * <ul>
     * <li><code>order</code>: The OrderIf object</li>
     * <li><code>customerName</code>: The name of the customer in the format firstName lastName</li>
     * <li><code>customer</code>: The CustomerIf object</li>
     * <li><code>storeOwner</code>: The name of the store owner.</li>
     * <li><code>storeName</code>: The name of the store.</li>
     * <li><code>storeOwnerEmailAddr</code>: The email address of the store owner.</li>
     * <li><code>dateTool</code>: org.apache.velocity.tools.generic.DateTool object used to format
     * dates.</li>
     * <li><code>locale</code>: java.util.Locale object</li>
     * <li><code>currencyMgr</code>: Used to format prices</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param langIdForOrder
     *            The languageId used for retrieving the order, to translate things such as order
     *            status. Value of -1 selects the default language.
     * @param options
     *            Options for the email
     * @return Returns an Email object containing the content of the email
     * @throws KKException
     */
     public EmailIf sendOrderConfirmationEmail1(String sessionId, int orderId, int langIdForOrder, EmailOptionsIf options) throws KKException
     {
         try
         {
            if (_sendOrderConfirmationEmail1 == null)
            {
                _sendOrderConfirmationEmail1 = new SendOrderConfirmationEmail1(kkEng);
            }

            return _sendOrderConfirmationEmail1.sendOrderConfirmationEmail1(sessionId, orderId, langIdForOrder, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A secret key is generated and stored in the database for the orderId passed as a parameter.
     * 
     * @param orderId
     * @return Returns the secret key
     * @throws KKException
     */
     public String getSecretKeyForOrderId(int orderId) throws KKException
     {
         try
         {
            if (_getSecretKeyForOrderId == null)
            {
                _getSecretKeyForOrderId = new GetSecretKeyForOrderId(kkEng);
            }

            return _getSecretKeyForOrderId.getSecretKeyForOrderId(orderId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * When an order is created, a secret key is generated that may be used to send to the payment
     * gateway if the payment gateway uses a callback mechanism. The payment gateway should re-send
     * the secret key as a parameter of the callback so that we can look up the order referenced by
     * the key. The secret key is unique for each order.
     * 
     * @param secretKey
     *            A string representing the secret key
     * @return Returns the orderId referenced to by the secretKey. A negative number is returned if
     *         no order is found.
     * @throws KKException
     */
     public int getOrderIdFromSecretKey(String secretKey) throws KKException
     {
         try
         {
            if (_getOrderIdFromSecretKey == null)
            {
                _getOrderIdFromSecretKey = new GetOrderIdFromSecretKey(kkEng);
            }

            return _getOrderIdFromSecretKey.getOrderIdFromSecretKey(secretKey);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The secret key is removed from the system. This should be done once payment has been received
     * and no other callbacks are expected from the payment gateway.
     * 
     * @param secretKey
     *            A string representing the secret key
     * @throws KKException
     */
     public void deleteOrderIdForSecretKey(String secretKey) throws KKException
     {
         try
         {
            if (_deleteOrderIdForSecretKey == null)
            {
                _deleteOrderIdForSecretKey = new DeleteOrderIdForSecretKey(kkEng);
            }

            _deleteOrderIdForSecretKey.deleteOrderIdForSecretKey(secretKey);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A new IpnHistory (Instant Product Notification) record is created in the database. This
     * should be called every time a payment gateway does a callback with information about the
     * payment. The saved record contains data received from the payment gateway, the exact format
     * of which is normally defined by the code that is called when the callback is received.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param ipnHistory
     *            The IpnHistory object to save
     * @return Returns the id of the new ipnHistory object
     * @throws KKException
     */
     public int saveIpnHistory(String sessionId, IpnHistoryIf ipnHistory) throws KKException
     {
         try
         {
            if (_saveIpnHistory == null)
            {
                _saveIpnHistory = new SaveIpnHistory(kkEng);
            }

            return _saveIpnHistory.saveIpnHistory(sessionId, ipnHistory);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * It updates the number of times that the manufacturer referenced by
     * <code>manufacturerId</code>, has been clicked on, to view the home page. The
     * <code>languageId</code> is required because a separate count is kept for how many times the
     * manufacturer home page has been viewed in each supported language.
     * 
     * @param manufacturerId
     *            The numeric id of the manufacturer
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @throws KKException
     */
     public void updateManufacturerViewedCount(int manufacturerId, int languageId) throws KKException
     {
         try
         {
            if (_updateManufacturerViewedCount == null)
            {
                _updateManufacturerViewedCount = new UpdateManufacturerViewedCount(kkEng);
            }

            _updateManufacturerViewedCount.updateManufacturerViewedCount(manufacturerId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Zone objects for the country referenced by the <code>countryId</code>.
     * 
     * @param countryId
     *            The numeric id of the country
     * @return Return an array of Zone objects
     * @throws KKException
     */
     public ZoneIf[] getZonesPerCountry(int countryId) throws KKException
     {
         try
         {
            if (_getZonesPerCountry == null)
            {
                _getZonesPerCountry = new GetZonesPerCountry(kkEng);
            }

            return _getZonesPerCountry.getZonesPerCountry(countryId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Search for zones using various search criteria
     * 
     * @param search
     * @return Returns an array of Zone objects
     * @throws KKException
     */
     public ZoneIf[] searchForZones(ZoneSearchIf search) throws KKException
     {
         try
         {
            if (_searchForZones == null)
            {
                _searchForZones = new SearchForZones(kkEng);
            }

            return _searchForZones.searchForZones(search);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Wherever in the engine any configurations have been cached, they are refreshed when this
     * method is called.
     * 
     * @throws KKException
     */
     public void updateCachedConfigurations() throws KKException
     {
         try
         {
            if (_updateCachedConfigurations == null)
            {
                _updateCachedConfigurations = new UpdateCachedConfigurations(kkEng);
            }

            _updateCachedConfigurations.updateCachedConfigurations();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Determine whether a customer has already registered with a certain eMail address as their
     * user name.
     * 
     * @param emailAddr
     *            The user name in the format of an email address
     * @return Returns true if a customer is registered with the eMail address passed in as a
     *         parameter. Otherwise it returns false.
     * @throws KKException
     */
     public boolean doesCustomerExistForEmail(String emailAddr) throws KKException
     {
         try
         {
            if (_doesCustomerExistForEmail == null)
            {
                _doesCustomerExistForEmail = new DoesCustomerExistForEmail(kkEng);
            }

            return _doesCustomerExistForEmail.doesCustomerExistForEmail(emailAddr);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Determines whether the eMail address is valid
     * 
     * @param emailAddr
     *            A string representing an email address
     * @return Returns true if the email address is valid. Otherwise returns false.
     * @throws KKException
     */
     public boolean isEmailValid(String emailAddr) throws KKException
     {
         try
         {
            if (_isEmailValid == null)
            {
                _isEmailValid = new IsEmailValid(kkEng);
            }

            return _isEmailValid.isEmailValid(emailAddr);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Receives an array of basket items and updates each one with the current stock level. This is
     * a useful check to make before checking out, to see whether the stock level is sufficient. The
     * Date Available is also set to return information as to when the products will be available if
     * they aren't in stock.
     * <p>
     * If the product or any of the product attributes of a basket item no longer exist, then that
     * basket item is not returned. This means that the size of the returned array may be smaller
     * than the size of the array passed in as a parameter.
     * 
     * @param basketItems
     *            An array of basket items
     * @return Returns an array of basket items with updated stock level
     * @throws KKException
     */
     public BasketIf[] updateBasketWithStockInfo(BasketIf[] basketItems) throws KKException
     {
         try
         {
            if (_updateBasketWithStockInfo == null)
            {
                _updateBasketWithStockInfo = new UpdateBasketWithStockInfo(kkEng);
            }

            return _updateBasketWithStockInfo.updateBasketWithStockInfo(basketItems);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Receives an array of basket items and updates each one with the current stock level. This is
     * a useful check to make before checking out, to see whether the stock level is sufficient. The
     * Date Available is also set to return information as to when the products will be available if
     * they aren't in stock.
     * <p>
     * If the product or any of the product attributes of a basket item no longer exist, then that
     * basket item is not returned. This means that the size of the returned array may be smaller
     * than the size of the array passed in as a parameter.
     * <p>
     * If options is set to null, this method is identical to updateBasketWithStockInfo(). Otherwise
     * the functionality differs depending on the combination of options set.
     * 
     * @param basketItems
     *            An array of basket items
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of basket items with updated stock level
     * @throws KKException
     */
     public BasketIf[] updateBasketWithStockInfoWithOptions(BasketIf[] basketItems, AddToBasketOptionsIf options) throws KKException
     {
         try
         {
            if (_updateBasketWithStockInfoWithOptions == null)
            {
                _updateBasketWithStockInfoWithOptions = new UpdateBasketWithStockInfoWithOptions(kkEng);
            }

            return _updateBasketWithStockInfoWithOptions.updateBasketWithStockInfoWithOptions(basketItems, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The stock level of the product and the date available are returned within a ProductQuantity
     * object. An exception is thrown if the product doesn't exist or if the encoded product id has
     * an invalid format. The format of the encoded product id is 1{2}3{4}5 where the product id =
     * 1, the first optionId / valueId pair have ids of 2,3 and the 2nd optionId / valueId pair have
     * ids of 4,5. If the product has no attributes then the encodedProductId should be just the
     * productId in String format.
     * <p>
     * If there are no option / value pairs then we use the stock level from the product object. If
     * there is at least one option / value pair, we attempt to find the quantity in the product
     * quantity table. If we can't find it in the product_quantity table we look for at least one
     * record in the product_quantity table for this product id. If we find something then we assume
     * that the quantity is zero. If we find no records, we use the quantity from the product
     * object.
     * 
     * @param encodedProductId
     *            The encoded product id which can reference a particular configuration of a
     *            product. i.e. A green shirt rather than a blue shirt.
     * @return A ProductQuantity object containing the stock level of the product and the date
     *         available.
     * @throws KKException
     */
     public ProductQuantityIf getProductQuantity(String encodedProductId) throws KKException
     {
         try
         {
            if (_getProductQuantity == null)
            {
                _getProductQuantity = new GetProductQuantity(kkEng);
            }

            return _getProductQuantity.getProductQuantity(encodedProductId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The stock level of the product and the date available are returned within a ProductQuantity
     * object. An exception is thrown if the product doesn't exist or if the encoded product id has
     * an invalid format. The format of the encoded product id is 1{2}3{4}5 where the product id =
     * 1, the first optionId / valueId pair have ids of 2,3 and the 2nd optionId / valueId pair have
     * ids of 4,5. If the product has no attributes then the encodedProductId should be just the
     * productId in String format.
     * <p>
     * If there are no option / value pairs then we use the stock level from the product object. If
     * there is at least one option / value pair, we attempt to find the quantity in the product
     * quantity table. If we can't find it in the product_quantity table we look for at least one
     * record in the product_quantity table for this product id. If we find something then we assume
     * that the quantity is zero. If we find no records, we use the quantity from the product
     * object.
     * <p>
     * The options object is used to set whether the quantity and available date should be fetched
     * from an external table based on the catalogId.
     * 
     * @param encodedProductId
     *            The encoded product id which can reference a particular configuration of a
     *            product. i.e. A green shirt rather than a blue shirt.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return A ProductQuantity object containing the stock level of the product and the date
     *         available.
     * @throws KKException
     */
     public ProductQuantityIf getProductQuantityWithOptions(String encodedProductId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductQuantityWithOptions == null)
            {
                _getProductQuantityWithOptions = new GetProductQuantityWithOptions(kkEng);
            }

            return _getProductQuantityWithOptions.getProductQuantityWithOptions(encodedProductId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A high level call to simplify the process of creating a KonaKart order. It is convenient to
     * use this call especially when KonaKart is integrated within another application such as a
     * Content Management System.
     * <p>
     * The caller supplies the user name (email address) and password of the KonaKart user. If the
     * user has not yet been registered, then the caller must also supply a populated
     * CustomerRegistration object, otherwise this can be set to null. The registration is done
     * automatically if the email address doesn't exist in the KonaKart database.
     * <p>
     * The shipping and payment module names must be names of modules that have been installed in
     * the KonaKart engine.
     * 
     * @param emailAddr
     *            The user name of the customer creating the order
     * @param password
     *            The password of the customer creating the order
     * @param custReg
     *            Object that contains all necessary details to register a new customer. Can be set
     *            to null if user has already been registered.
     * @param basketItemArray
     *            Array of basket items to add to the order
     * @param shippingModule
     *            Shipping module to use (null if no shipping required). This parameter must contain
     *            the name of the module (i.e. flat or item or table..)
     * @param paymentModule
     *            Payment module to use. This parameter must contain the name of the module (i.e.
     *            chronopay or cod or worldpay..)
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an Order object with payment details so that the calling application can call
     *         the payment gateway.
     * @throws KKException
     */
     public OrderIf createAndSaveOrder(String emailAddr, String password, CustomerRegistrationIf custReg, BasketIf[] basketItemArray, String shippingModule, String paymentModule, int languageId) throws KKException
     {
         try
         {
            if (_createAndSaveOrder == null)
            {
                _createAndSaveOrder = new CreateAndSaveOrder(kkEng);
            }

            return _createAndSaveOrder.createAndSaveOrder(emailAddr, password, custReg, basketItemArray, shippingModule, paymentModule, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is deprecated since release 4.0.0.0 because an SKU attribute was added to the
     * OrderProduct.
     * 
     * @param orderProd
     *            The OrderProduct object. An order normally contains an array of order product
     *            objects.
     * @return Returns the SKU for the OrderProduct
     * @throws KKException
     * @deprecated
     */
    @Deprecated
     public String getSku(OrderProductIf orderProd) throws KKException
     {
         try
         {
            if (_getSku == null)
            {
                _getSku = new GetSku(kkEng);
            }

            return _getSku.getSku(orderProd);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Set the Web Service endpoint for the engine. This is only applicable when calling a KonaKart
     * engine via web services.
     * <p>
     * The effect will be to set the web service endpoint for the proxy to the KonaKart engine.
     * 
     * @param wsEndpoint
     *            A String representing the web service endpoint
     * @throws KKException
     */
     public void setEndpoint(String wsEndpoint) throws KKException
     {
         try
         {
            if (_setEndpoint == null)
            {
                _setEndpoint = new SetEndpoint(kkEng);
            }

            _setEndpoint.setEndpoint(wsEndpoint);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Create and insert a digital download record for the product identified by the
     * <code>productId</code> and the customer identified by the <code>sessionId</code>. If the
     * digital download already exists, then we overwrite it with the new one.
     * <p>
     * The attributes of the digital download product such as the maximum number of days that it is
     * valid and how many times it can be downloaded, are retrieved from configuration variables or
     * from the product directly.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param productId
     *            The numeric id of the product
     * @return Returns the id of the inserted Digital Download
     * @throws KKException
     */
     public int insertDigitalDownload(String sessionId, int productId) throws KKException
     {
         try
         {
            if (_insertDigitalDownload == null)
            {
                _insertDigitalDownload = new InsertDigitalDownload(kkEng);
            }

            return _insertDigitalDownload.insertDigitalDownload(sessionId, productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Digital Download objects for the customer identified by the
     * <code>sessionId</code> parameter. The product attribute of the Digital Download objects is
     * not populated.
     * <p>
     * If the DD_DELETE_ON_EXPIRATION configuration variable is set to "true", then the objects read
     * from the database that have expired, are automatically deleted. This avoids having to
     * maintain the database table. Regardless of the setting of DD_DELETE_ON_EXPIRATION, only valid
     * (not expired) objects are ever returned.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Returns an array of DigitalDownload objects
     * @throws KKException
     */
     public DigitalDownloadIf[] getDigitalDownloads(String sessionId) throws KKException
     {
         try
         {
            if (_getDigitalDownloads == null)
            {
                _getDigitalDownloads = new GetDigitalDownloads(kkEng);
            }

            return _getDigitalDownloads.getDigitalDownloads(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Digital Download objects for the customer identified by the
     * <code>sessionId</code> parameter. The <code>ddOptions</code> parameter allows you to define
     * whether the product attribute of the returned Digital Download objects is populated.
     * <p>
     * If the DD_DELETE_ON_EXPIRATION configuration variable is set to "true", then the objects read
     * from the database that have expired, are automatically deleted. This avoids having to
     * maintain the database table. Regardless of the setting of DD_DELETE_ON_EXPIRATION, only valid
     * (not expired) objects are ever returned.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param languageId
     *            The id for the language that will be used for the digital download products. Value
     *            of -1 selects the default language.
     * @param ddOptions
     *            Options object that allows you to define whether the product attribute of the
     *            returned Digital Download objects is populated. It may be set to null.
     * @param prodOptions
     *            An object containing options for the digital download products. It may be set to
     *            null.
     * @return Returns an array of DigitalDownload objects
     * @throws KKException
     */
     public DigitalDownloadIf[] getDigitalDownloadsWithOptions(String sessionId, int languageId, FetchDigitalDownloadOptionsIf ddOptions, FetchProductOptionsIf prodOptions) throws KKException
     {
         try
         {
            if (_getDigitalDownloadsWithOptions == null)
            {
                _getDigitalDownloadsWithOptions = new GetDigitalDownloadsWithOptions(kkEng);
            }

            return _getDigitalDownloadsWithOptions.getDigitalDownloadsWithOptions(sessionId, languageId, ddOptions, prodOptions);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Updates the count of the Digital Download identified by the <code>productId</code> and the
     * customer identified by the <code>sessionId</code>. The count defines how many times it has
     * been downloaded.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param productId
     *            The numeric id of the product
     * @return Returns the new count
     * @throws KKException
     */
     public int updateDigitalDownloadCount(String sessionId, int productId) throws KKException
     {
         try
         {
            if (_updateDigitalDownloadCount == null)
            {
                _updateDigitalDownloadCount = new UpdateDigitalDownloadCount(kkEng);
            }

            return _updateDigitalDownloadCount.updateDigitalDownloadCount(sessionId, productId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Updates the count of the Digital Download identified by the <code>digitalDownloadId</code>
     * and the customer identified by the <code>sessionId</code>. The count defines how many times
     * it has been downloaded. This is used when there may be many digital downloads for the same
     * product pointing to different files. i.e. Tickets
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param digitalDownloadId
     *            The numeric id of the digital download object
     * @return Returns the new count
     * @throws KKException
     */
     public int updateDigitalDownloadCountById(String sessionId, int digitalDownloadId) throws KKException
     {
         try
         {
            if (_updateDigitalDownloadCountById == null)
            {
                _updateDigitalDownloadCountById = new UpdateDigitalDownloadCountById(kkEng);
            }

            return _updateDigitalDownloadCountById.updateDigitalDownloadCountById(sessionId, digitalDownloadId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * When a customer that hasn't logged in adds products to the shopping cart, we use a temporary
     * customer id which is always negative and unique. This is the engine call used to get the
     * unique negative id.
     * 
     * @return The latest temporaryId
     * @throws KKException
     */
     public int getTempCustomerId() throws KKException
     {
         try
         {
            if (_getTempCustomerId == null)
            {
                _getTempCustomerId = new GetTempCustomerId(kkEng);
            }

            return _getTempCustomerId.getTempCustomerId();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of customer groups for all customer groups that have been defined in the
     * system. The groups returned are those for the language defined by languageId.
     * 
     * @param languageId
     *            The id for the language that will be used to determine the customer group name and
     *            description. Value of -1 selects the default language.
     * @return An array of customer group objects.
     * @throws KKException
     */
     public CustomerGroupIf[] getAllCustomerGroups(int languageId) throws KKException
     {
         try
         {
            if (_getAllCustomerGroups == null)
            {
                _getAllCustomerGroups = new GetAllCustomerGroups(kkEng);
            }

            return _getAllCustomerGroups.getAllCustomerGroups(languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a customer group object for the customerGroupId passed in as a parameter.
     * 
     * @param customerGroupId
     * @param languageId
     *            The id for the language that will be used to determine the customer group name and
     *            description. Value of -1 selects the default language.
     * @return A customer group object.
     * @throws KKException
     */
     public CustomerGroupIf getCustomerGroup(int customerGroupId, int languageId) throws KKException
     {
         try
         {
            if (_getCustomerGroup == null)
            {
                _getCustomerGroup = new GetCustomerGroup(kkEng);
            }

            return _getCustomerGroup.getCustomerGroup(customerGroupId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used to send a template based eMail to a customer identified by the
     * customerId. The attributes that the velocity template has access to are:
     * <ul>
     * <li>customer - Customer object</li>
     * <li>message - message passed in as a parameter</li>
     * <li>storeOwner - Name of the store owner</li>
     * <li>storeName - Name of the store</li>
     * <li>storeOwnerEmailAddr - eMail address of the store owner</li>
     * </ul>
     * <p>
     * We ship an example template called GenericCustEmail_en.vm . Note that the first line of the
     * template is used to generate the subject of the eMail.
     * 
     * @param customerId
     *            The numeric id of the customer
     * @param templateName
     *            The name of the template, not including "_countryCode.vm". If the template file
     *            name is CustomEmail_en.vm, the parameter must be set to CustomEmail.
     * @param message
     *            The information within the message may be used by the template.
     * @param countryCode
     *            The two letter country code used to select the velocity template that creates the
     *            mail.
     * @throws KKException
     * @deprecated
     */
    @Deprecated
     public void sendTemplateEmailToCustomer(int customerId, String templateName, String message, String countryCode) throws KKException
     {
         try
         {
            if (_sendTemplateEmailToCustomer == null)
            {
                _sendTemplateEmailToCustomer = new SendTemplateEmailToCustomer(kkEng);
            }

            _sendTemplateEmailToCustomer.sendTemplateEmailToCustomer(customerId, templateName, message, countryCode);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used to send a template based eMail to a customer identified by the
     * customerId.
     * <p>
     * Valid options are:
     * <ul>
     * <li><code>templateName</code>: The name of the template used to send the mail without the
     * country code and the .vm extension. e.g. If the name of the template is myTemplate and the
     * two letter country code is en, then KonaKart will search for a template called
     * myTemplate_en.vm .</li>
     * <li><code>countryCode</code>: The two letter (lower case) country code used to search for the
     * template. e.g. en, de, es etc.</li>
     * <li><code>customAttrs</code>: An array of name value pairs used to pass custom information to
     * the Velocity engine. The value can be retrieved from the template using the name preceded by
     * the $ sign. e.g. If a name value pair contains StoreId and 22, the value 22 will be displayed
     * in the eMail where the template contains $StoreId.</li>
     * <li><code>fullAttachmentFilename</code>: The complete filename of an attachment.</li>
     * <li><code>friendlyAttachmentName</code>: The friendly filename of an attachment that can be
     * viewed from the eMail.</li>
     * <li><code>deleteAttachmentAfterSend</code>: When set to <code>true</code>, the attachment is
     * deleted after being sent. The default value is <code>false</code>.</li>
     * </ul>
     * <p>
     * The Velocity context contains the following data:
     * <ul>
     * <li><code>customerName</code>: The name of the customer in the format firstName lastName</li>
     * <li><code>customer</code>: The CustomerIf object</li>
     * <li><code>message</code>: The message that may be used by the template</li>
     * <li><code>storeOwner</code>: The name of the store owner.</li>
     * <li><code>storeName</code>: The name of the store.</li>
     * <li><code>storeOwnerEmailAddr</code>: The email address of the store owner.</li>
     * <li><code>dateTool</code>: org.apache.velocity.tools.generic.DateTool object used to format
     * dates.</li>
     * <li><code>locale</code>: java.util.Locale object</li>
     * <li><code>currencyMgr</code>: Used to format prices</li>
     * </ul>
     * 
     * @param customerId
     *            The numeric id of the customer
     * @param message
     *            The information within the message may be used by the template.
     * @param options
     *            Options for the email
     * @return Returns an Email object containing the content of the email
     * @throws KKException
     */
     public EmailIf sendTemplateEmailToCustomer1(int customerId, String message, EmailOptionsIf options) throws KKException
     {
         try
         {
            if (_sendTemplateEmailToCustomer1 == null)
            {
                _sendTemplateEmailToCustomer1 = new SendTemplateEmailToCustomer1(kkEng);
            }

            return _sendTemplateEmailToCustomer1.sendTemplateEmailToCustomer1(customerId, message, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Used to log in to the application as a customer by an Administrator. This is useful for Call
     * Center type applications where the Call Center person can log into the application as the
     * customer without requiring the customer's credentials, in order to perform some action on
     * behalf of the customer.
     * <p>
     * The adminSession must contain the session of a logged in Administrator User. The customerId
     * must contain the Id of the customer to login as.
     * 
     * @param adminSession
     *            The session of a logged in administrator user
     * @param customerId
     *            The id of the customer to login as
     * @return Returns the sessionId for the customer's session
     * @throws KKException
     */
     public String loginByAdmin(String adminSession, int customerId) throws KKException
     {
         try
         {
            if (_loginByAdmin == null)
            {
                _loginByAdmin = new LoginByAdmin(kkEng);
            }

            return _loginByAdmin.loginByAdmin(adminSession, customerId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A custom interface that you have to provide an implementation for. The default implementation
     * will simply return a null.
     * <p>
     * There are two versions, one that requires a valid sessionId (customSecure) and one that does
     * not (custom).
     * <p>
     * You are free to use the two input String parameters in any way you choose, for example you
     * may wish to use one to indicate which of your custom functions to run, and the other might
     * contain XML to give you a great deal of flexibility - but it's up to you!
     * 
     * @param input1
     *            The first input String - can be anything you choose
     * @param input2
     *            The second input String - can be anything you choose
     * @return Returns a String
     * @throws KKException
     */
     public String custom(String input1, String input2) throws KKException
     {
         try
         {
            if (_custom == null)
            {
                _custom = new Custom(kkEng);
            }

            return _custom.custom(input1, input2);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A custom interface that you have to provide an implementation for. The default implementation
     * will throw an exception for an invalid sessionId or return a null.
     * <p>
     * There are two versions, one that requires a valid sessionId (customSecure) and one that does
     * not (custom).
     * <p>
     * You are free to use the two input String parameters in any way you choose, for example you
     * may wish to use one to indicate which of your custom functions to run, and the other might
     * contain XML to give you a great deal of flexibility - but it's up to you!
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param input1
     *            The first input String - can be anything you choose
     * @param input2
     *            The second input String - can be anything you choose
     * @return Returns a String
     * @throws KKException
     */
     public String customSecure(String sessionId, String input1, String input2) throws KKException
     {
         try
         {
            if (_customSecure == null)
            {
                _customSecure = new CustomSecure(kkEng);
            }

            return _customSecure.customSecure(sessionId, input1, input2);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return an array of TagGroup objects for a category. Each TagGroup is populated with an array
     * of Tags which are sorted first by sort order and then by name. An empty array is returned if
     * no TagGroup objects exist.
     * 
     * @param categoryId
     *            The numeric id of the category
     * @param getProdCount
     *            If true, the Tag objects are populated with the number of products present for the
     *            tag
     * @param languageId
     *            The id for the language that will be used to determine the tag group name and
     *            description. Value of -1 selects the default language.
     * @return Returns an array of TagGroup objects. An empty array is returned if no TagGroup
     *         objects exist.
     * @throws KKException
     */
     public TagGroupIf[] getTagGroupsPerCategory(int categoryId, boolean getProdCount, int languageId) throws KKException
     {
         try
         {
            if (_getTagGroupsPerCategory == null)
            {
                _getTagGroupsPerCategory = new GetTagGroupsPerCategory(kkEng);
            }

            return _getTagGroupsPerCategory.getTagGroupsPerCategory(categoryId, getProdCount, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return an array of TagGroup objects for a category. The options object allows you to define:
     * <ul>
     * <li>Whether to populate the tag groups with tags. When using Solr for faceted searching, this
     * can be set to false since the tags aren't required</li>
     * <li>Whether to populate the Tag objects with the number of products present for the tag</li>
     * </ul>
     * An empty array is returned if no TagGroup objects exist.
     * 
     * @param categoryId
     *            The numeric id of the category
     * @param languageId
     *            The id for the language that will be used to determine the tag group name and
     *            description. Value of -1 selects the default language.
     * @param options
     *            An object containing options for the method.
     * @return Returns an array of TagGroup objects. An empty array is returned if no TagGroup
     *         objects exist.
     * @throws KKException
     */
     public TagGroupIf[] getTagGroupsPerCategoryWithOptions(int categoryId, int languageId, FetchTagGroupOptionsIf options) throws KKException
     {
         try
         {
            if (_getTagGroupsPerCategoryWithOptions == null)
            {
                _getTagGroupsPerCategoryWithOptions = new GetTagGroupsPerCategoryWithOptions(kkEng);
            }

            return _getTagGroupsPerCategoryWithOptions.getTagGroupsPerCategoryWithOptions(categoryId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return an array of Tag objects for a category. An empty array is returned if no Tag objects
     * exist. The Tags are sorted first by sort order and then by name.
     * 
     * @param categoryId
     *            The numeric id of the category
     * @param getProdCount
     *            If true, the Tag objects are populated with the number of products
     * @param languageId
     *            The id for the language that will be used to determine the tag name. Value of -1
     *            selects the default language.
     * @return Returns an array of Tag objects
     * @throws KKException
     */
     public TagIf[] getTagsPerCategory(int categoryId, boolean getProdCount, int languageId) throws KKException
     {
         try
         {
            if (_getTagsPerCategory == null)
            {
                _getTagsPerCategory = new GetTagsPerCategory(kkEng);
            }

            return _getTagsPerCategory.getTagsPerCategory(categoryId, getProdCount, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a TagGroup object for the id passed in as a parameter. The TagGroup is populated with
     * an array of Tags which are sorted first by sort order and then by name. Null is returned if
     * the TagGroup object doesn't exist.
     * 
     * @param tagGroupId
     *            The numeric Id of the tag group
     * @param getProdCount
     *            If true, the Tag objects are populated with the number of products
     * @param languageId
     *            The id for the language that will be used to determine the tag group name and
     *            description. Value of -1 selects the default language.
     * @return Returns a TagGroup object
     * @throws KKException
     */
     public TagGroupIf getTagGroup(int tagGroupId, boolean getProdCount, int languageId) throws KKException
     {
         try
         {
            if (_getTagGroup == null)
            {
                _getTagGroup = new GetTagGroup(kkEng);
            }

            return _getTagGroup.getTagGroup(tagGroupId, getProdCount, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Tag object for the id passed in as a parameter.
     * 
     * @param tagId
     *            The numeric Id of the tag
     * @param getProdCount
     *            If true, the Tag object is populated with the number of products
     * @param languageId
     *            The id for the language that will be used to determine the tag name. Value of -1
     *            selects the default language.
     * @return Returns a Tag object
     * @throws KKException
     */
     public TagIf getTag(int tagId, boolean getProdCount, int languageId) throws KKException
     {
         try
         {
            if (_getTag == null)
            {
                _getTag = new GetTag(kkEng);
            }

            return _getTag.getTag(tagId, getProdCount, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the customer object for the default customer. If more than one default customer
     * exists (which shouldn't be the case), it returns one of the customers found. If no default
     * customer is found, it returns null.
     * <p>
     * The default customer can be configured in the Admin App. It is a fictitious customer with a
     * real address that is used to create a temporary order even when a customer is not logged in
     * or hasn't registered yet. The order totals of this temporary order are displayed in the cart
     * details screen to give an indication of shipping costs and to display any available
     * discounts.
     * 
     * @return Customer Object or Null if the default customer doesn't exist.
     * @throws KKException
     */
     public CustomerIf getDefaultCustomer() throws KKException
     {
         try
         {
            if (_getDefaultCustomer == null)
            {
                _getDefaultCustomer = new GetDefaultCustomer(kkEng);
            }

            return _getDefaultCustomer.getDefaultCustomer();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The EngineConfig is the configuration object passed to the engine at the time of
     * instantiation.
     * 
     * @return Returns the EngineConfig object.
     */
    public EngineConfigIf getEngConf()
    {
        return engConf;
    }


    /**
     * Returns an array of strings containing the store ids for the stores being used in a
     * multi-store / multi-database environment. It may return null or an empty array if not
     * applicable. In a multi-store / multi-database environment, each KonaKart database instance
     * may only be configured to connect to a number of stores and so it is necessary to know which
     * stores the engine will connect to. In a multi-store / single-database environment, the method
     * isn't applicable since each engine instance can connect to all stores.
     * 
     * @return Returns an array of strings containing the store ids for the stores being used in a
     *         multi-store / multi-database environment.
     * @throws KKException
     */
     public String[] getStoreIds() throws KKException
     {
         try
         {
            if (_getStoreIds == null)
            {
                _getStoreIds = new GetStoreIds(kkEng);
            }

            return _getStoreIds.getStoreIds();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The credit card details in the CreditCard object passed in as a parameter, are saved in the
     * database for an existing order. Before being saved, this sensitive information is encrypted.
     * <p>
     * No update or insert is done for attributes of the CreditCard object that are set to null. The
     * credit card details are mapped as follows to attributes in the order object:
     * <ul>
     * <li>e1 - Credit Card owner</li>
     * <li>e2 - Credit Card number</li>
     * <li>e3 - Credit Card expiration</li>
     * <li>e4 - Credit Card CVV</li>
     * <li>e5 - Credit Card Type</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @param card
     *            CreditCard object containing the credit card details
     * @throws KKException
     */
     public void setCreditCardDetailsOnOrder(String sessionId, int orderId, CreditCardIf card) throws KKException
     {
         try
         {
            if (_setCreditCardDetailsOnOrder == null)
            {
                _setCreditCardDetailsOnOrder = new SetCreditCardDetailsOnOrder(kkEng);
            }

            _setCreditCardDetailsOnOrder.setCreditCardDetailsOnOrder(sessionId, orderId, card);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Add a WishListItem object to the wish list referenced by wishListId. If the wish list doesn't
     * belong to the logged in customer, an exception is thrown. If the WishListItem already exists,
     * then it is updated. The customer must be logged in with a valid sessionId when this method is
     * called.
     * <p>
     * The compulsory attributes for the WishListItem are:
     * <ul>
     * <li>productId</li>
     * <li>wishListId</li>
     * </ul>
     * <p>
     * The WishListItem may also contain an array of options if these are applicable for the chosen
     * product.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListItem
     *            The wish list item to be added to the wish list
     * @return Returns the id of the new wishListItem object
     * @throws KKException
     */
     public int addToWishList(String sessionId, WishListItemIf wishListItem) throws KKException
     {
         try
         {
            if (_addToWishList == null)
            {
                _addToWishList = new AddToWishList(kkEng);
            }

            return _addToWishList.addToWishList(sessionId, wishListItem);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If <code>options</code> is set to null, this method is identical to
     * <code>addToWishList()</code>. Otherwise the functionality differs depending on the
     * combination of options set.
     * <p>
     * Add a WishListItem object to the wish list referenced by wishListId. The sessionId may be
     * left null if a temporary customer id (negative number) is added to the options object. If the
     * wish list doesn't belong to the logged in customer or the customer referenced by the customer
     * id, an exception is thrown. If the WishListItem already exists, then it is updated.
     * <p>
     * The compulsory attributes for the WishListItem are:
     * <ul>
     * <li>productId</li>
     * <li>wishListId</li>
     * </ul>
     * <p>
     * The WishListItem may also contain an array of options if these are applicable for the chosen
     * product.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListItem
     *            The wish list item to be added to the wish list
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns the id of the new wishListItem object
     * @throws KKException
     */
     public int addToWishListWithOptions(String sessionId, WishListItemIf wishListItem, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_addToWishListWithOptions == null)
            {
                _addToWishListWithOptions = new AddToWishListWithOptions(kkEng);
            }

            return _addToWishListWithOptions.addToWishListWithOptions(sessionId, wishListItem, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Create a wish list from a WishList object. Once created, the method
     * <code>addToWishList()</code> can be called to add wish list items to the wish list. The
     * customer must be logged in with a valid sessionId when this method is called.
     * <p>
     * The compulsory attributes for the WishListItem are:
     * <ul>
     * <li>publicWishList</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishList
     *            The wish list to be created
     * @return Returns the id of the new WishList object
     * @throws KKException
     */
     public int createWishList(String sessionId, WishListIf wishList) throws KKException
     {
         try
         {
            if (_createWishList == null)
            {
                _createWishList = new CreateWishList(kkEng);
            }

            return _createWishList.createWishList(sessionId, wishList);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Create a wish list from a WishList object. Once created, the method
     * <code>addToWishList()</code> can be called to add wish list items to the wish list. This
     * method may be called even when a customer isn't logged in. In this case the
     * <code>customerId</code> attribute of the options object must be set to the id of the
     * temporary customer which is negative.
     * <p>
     * The compulsory attributes for the WishListItem are:
     * <ul>
     * <li>publicWishList</li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishList
     *            The wish list to be created
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns the id of the new WishList object
     * @throws KKException
     */
     public int createWishListWithOptions(String sessionId, WishListIf wishList, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_createWishListWithOptions == null)
            {
                _createWishListWithOptions = new CreateWishListWithOptions(kkEng);
            }

            return _createWishListWithOptions.createWishListWithOptions(sessionId, wishList, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Edit an existing wish list object. A check is made that the wish list actually belongs to the
     * user referenced by the session id. The customer must be logged in with a valid sessionId when
     * this method is called.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishList
     *            The wish list to be edited
     * @throws KKException
     */
     public void editWishList(String sessionId, WishListIf wishList) throws KKException
     {
         try
         {
            if (_editWishList == null)
            {
                _editWishList = new EditWishList(kkEng);
            }

            _editWishList.editWishList(sessionId, wishList);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Edit an existing wish list object. The sessionId may be left null if a temporary customer id
     * (negative number) is added to the options object. A check is made that the wish list actually
     * belongs to the user referenced by the session id or customer id.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishList
     *            The wish list to be edited
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void editWishListWithOptions(String sessionId, WishListIf wishList, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_editWishListWithOptions == null)
            {
                _editWishListWithOptions = new EditWishListWithOptions(kkEng);
            }

            _editWishListWithOptions.editWishListWithOptions(sessionId, wishList, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The wish list referenced by wishListId and all of the items contained by the wish list, will
     * be deleted. An exception will be thrown if the wish list does not belong to the logged in
     * customer. The customer must be logged in with a valid sessionId when this method is called.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListId
     *            The numeric id of the wish list
     * @throws KKException
     */
     public void deleteWishList(String sessionId, int wishListId) throws KKException
     {
         try
         {
            if (_deleteWishList == null)
            {
                _deleteWishList = new DeleteWishList(kkEng);
            }

            _deleteWishList.deleteWishList(sessionId, wishListId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The wish list referenced by wishListId and all of the items contained by the wish list, will
     * be deleted. The sessionId may be left null if a temporary customer id (negative number) is
     * added to the options object. The WishListItem will only be deleted if the wish list belongs
     * to the logged in customer or the customer referenced by the customer id. An exception will be
     * thrown if the wish list does not belong to the logged in customer or customer referenced by
     * customerId.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListId
     *            The numeric id of the wish list
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void deleteWishListWithOptions(String sessionId, int wishListId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_deleteWishListWithOptions == null)
            {
                _deleteWishListWithOptions = new DeleteWishListWithOptions(kkEng);
            }

            _deleteWishListWithOptions.deleteWishListWithOptions(sessionId, wishListId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a fully populated WishList object that may contain an array of WishListItem objects.
     * An exception will be thrown if the wish list doesn't belong to the logged in customer and is
     * private. The customer must be logged in with a valid sessionId when this method is called.
     * <p>
     * Each WishListItem object will have a populated <code>product</code> attribute and populated
     * <code>opts</code> attribute if the WishListItem contains options. The items will be ordered
     * by priority with the highest priority first.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param wishListId
     *            The numeric id of the wish list
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns an array of WishListItem objects
     * @throws KKException
     */
     public WishListIf getWishListWithItems(String sessionId, int wishListId, int languageId) throws KKException
     {
         try
         {
            if (_getWishListWithItems == null)
            {
                _getWishListWithItems = new GetWishListWithItems(kkEng);
            }

            return _getWishListWithItems.getWishListWithItems(sessionId, wishListId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * If <code>options</code> is set to null, this method is identical to
     * <code>getWishListWithItems()</code>. Otherwise the functionality differs depending on the
     * combination of options set. The sessionId may be left null if a temporary customer id
     * (negative number) is added to the options object. An exception will be thrown if the wish
     * list doesn't belong to the logged in customer or customer referenced by customer id, and is
     * private.
     * <p>
     * Returns a fully populated WishList object that may contain an array of WishListItem objects.
     * An exception will be thrown if the wish list doesn't belong to the logged in customer and is
     * private.
     * <p>
     * Each WishListItem object will have a populated <code>product</code> attribute and populated
     * <code>opts</code> attribute if the WishListItem contains options. The items will be ordered
     * by priority with the highest priority first.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param wishListId
     *            The numeric id of the wish list
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of WishListItem objects
     * @throws KKException
     */
     public WishListIf getWishListWithItemsWithOptions(String sessionId, int wishListId, int languageId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_getWishListWithItemsWithOptions == null)
            {
                _getWishListWithItemsWithOptions = new GetWishListWithItemsWithOptions(kkEng);
            }

            return _getWishListWithItemsWithOptions.getWishListWithItemsWithOptions(sessionId, wishListId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a WishList object not populated with an array of WishListItem objects. An exception
     * is thrown if the wish list doesn't belong to the logged in customer and is private. Null is
     * returned if the wish list doesn't exist. The customer must be logged in with a valid
     * sessionId when this method is called.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param wishListId
     *            The numeric id of the wish list
     * @return Returns a Wish List object
     * @throws KKException
     */
     public WishListIf getWishList(String sessionId, int wishListId) throws KKException
     {
         try
         {
            if (_getWishList == null)
            {
                _getWishList = new GetWishList(kkEng);
            }

            return _getWishList.getWishList(sessionId, wishListId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a WishList object not populated with an array of WishListItem objects. The sessionId
     * may be left null if a temporary customer id (negative number) is added to the options object.
     * An exception will be thrown if the wish list doesn't belong to the logged in customer or
     * customer referenced by customer id, and is private. Null is returned if the wish list doesn't
     * exist. The customer must be logged in with a valid sessionId when this method is called.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param wishListId
     *            The numeric id of the wish list
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Wish List object
     * @throws KKException
     */
     public WishListIf getWishListWithOptions(String sessionId, int wishListId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_getWishListWithOptions == null)
            {
                _getWishListWithOptions = new GetWishListWithOptions(kkEng);
            }

            return _getWishListWithOptions.getWishListWithOptions(sessionId, wishListId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a WishListItems object containing an array of items and the number of items returned.
     * The DataDescriptor object can be user to sort and page the returned items. The sessionId may
     * be left null if a temporary customer id (negative number) is added to the options object. An
     * exception will be thrown if the wish list doesn't belong to the logged in customer or
     * customer referenced by customer id, and is private.
     * <p>
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of wish list item objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many wish list item
     * objects, in order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set, then only wish list
     * items with a matching custom attribute value are returned.</li>
     * <li>The wish list item may be sorted by :
     * <ul>
     * <li>Priority Ascending / Descending</li>
     * <li>Custom1 Ascending / Descending</li>
     * <li>Custom2 Ascending / Descending</li>
     * <li>Custom3 Ascending / Descending</li>
     * <li>Custom4 Ascending / Descending</li>
     * <li>Custom5 Ascending / Descending</li>
     * </ul>
     * </li>
     * </ul>
     * <p>
     * If the <code>onlyShowAvailable</code> attribute of the options object is set, then the wish
     * list items that have quantity received equal to quantity desired, are not returned.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param wishListId
     *            The numeric id of the WishList object that the wish list items belong to
     * @param languageId
     *            The numeric id of the language object
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a WishListItems objects
     * @throws KKException
     */
     public WishListItemsIf getWishListItemsWithOptions(String sessionId, DataDescriptorIf dataDesc, int wishListId, int languageId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_getWishListItemsWithOptions == null)
            {
                _getWishListItemsWithOptions = new GetWishListItemsWithOptions(kkEng);
            }

            return _getWishListItemsWithOptions.getWishListItemsWithOptions(sessionId, dataDesc, wishListId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a WishListItems object containing an array of items and the number of items returned.
     * The DataDescriptor object can be user to sort and page the returned items. An exception will
     * be thrown if the wish list doesn't belong to the logged in customer and is private.
     * <p>
     * However, by setting the attributes of <code>dataDesc</code>, the following functionality may
     * be controlled :
     * <ul>
     * <li>The maximum number of wish list item objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many wish list item
     * objects, in order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set, then only wish list
     * items with a matching custom attribute value are returned.</li>
     * <li>The wish list item may be sorted by :
     * <ul>
     * <li>Priority Ascending / Descending</li>
     * <li>Custom1 Ascending / Descending</li>
     * <li>Custom2 Ascending / Descending</li>
     * <li>Custom3 Ascending / Descending</li>
     * <li>Custom4 Ascending / Descending</li>
     * <li>Custom5 Ascending / Descending</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param wishListId
     *            The numeric id of the WishList object that the wish list items belong to
     * @param languageId
     *            The numeric id of the language object
     * @return Returns a WishListItems objects
     * @throws KKException
     */
     public WishListItemsIf getWishListItems(String sessionId, DataDescriptorIf dataDesc, int wishListId, int languageId) throws KKException
     {
         try
         {
            if (_getWishListItems == null)
            {
                _getWishListItems = new GetWishListItems(kkEng);
            }

            return _getWishListItems.getWishListItems(sessionId, dataDesc, wishListId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Remove the WishListItem object referenced by wishListItemId. The WishListItem will only be
     * deleted if the wish list belongs to the logged in customer. If the wish list does not belong
     * to the customer referenced by the sessionId, an exception will be thrown. The customer must
     * be logged in with a valid sessionId when this method is called.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListItemId
     *            The numeric id of the wish list item
     * @throws KKException
     */
     public void removeFromWishList(String sessionId, int wishListItemId) throws KKException
     {
         try
         {
            if (_removeFromWishList == null)
            {
                _removeFromWishList = new RemoveFromWishList(kkEng);
            }

            _removeFromWishList.removeFromWishList(sessionId, wishListItemId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Remove the WishListItem object referenced by wishListItemId. The sessionId may be left null
     * if a temporary customer id (negative number) is added to the options object. The WishListItem
     * will only be deleted if the wish list belongs to the logged in customer or the customer
     * referenced by the customer id. If the wish list does not belong to the customer referenced by
     * the sessionId or customer id, an exception will be thrown.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param wishListItemId
     *            The numeric id of the wish list item
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @throws KKException
     */
     public void removeFromWishListWithOptions(String sessionId, int wishListItemId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_removeFromWishListWithOptions == null)
            {
                _removeFromWishListWithOptions = new RemoveFromWishListWithOptions(kkEng);
            }

            _removeFromWishListWithOptions.removeFromWishListWithOptions(sessionId, wishListItemId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Add all items from the wish list of customerFrom to the wish list of customerTo which is
     * retrieved from the sessionId. This is done when a customer logs in, to move his temporary
     * wish list to his permanent wish list.
     * <p>
     * The currently logged in customer may have more than one wish list. The one used is the first
     * one found of listType == 0.
     * 
     * @param sessionId
     * @param customerFromId
     * @param languageId
     * @param options
     * @throws KKException
     */
     public void mergeWishListsWithOptions(String sessionId, int customerFromId, int languageId, AddToWishListOptionsIf options) throws KKException
     {
         try
         {
            if (_mergeWishListsWithOptions == null)
            {
                _mergeWishListsWithOptions = new MergeWishListsWithOptions(kkEng);
            }

            _mergeWishListsWithOptions.mergeWishListsWithOptions(sessionId, customerFromId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * All wish lists matching the search criteria will be returned. They will be grouped by
     * customerId. Note that in order to retrieve the wish list items, you must call the
     * <code>getWishListWithItems()</code> method, passing it the id of the wish list. This will
     * also populate the final price attributes of the wish list.
     * <p>
     * If customerSearch is null, then only the wish lists of the logged in customer will be
     * returned. If dataDesc is set to null, a default DataDescriptor will be used.
     * <p>
     * Only the following attributes of the CustomerSearchIf object will be used to search:
     * <ul>
     * <li>tmpId - to find wish lists for non logged in customers that have a negative customer id.
     * Will only be used if set to a negative number.</li>
     * <li>firstName - to find wish lists for all customers with this first name</li>
     * <li>lastName - to find wish lists for all customers with this last name</li>
     * <li>firstName1 - to find wish lists for all 2nd customers with this first name. i.e. Wedding
     * list</li>
     * <li>lastName1 - to find wish lists for all 2nd customers with this last name. i.e. Wedding
     * list</li>
     * <li>city - to find wish lists for all customers living in this city</li>
     * <li>state - to find wish lists for all customers living in this state</li>
     * <li>cityOrState - to find wish lists for all customers living in this city or state</li>
     * <li>eventDate - to find wish lists for events such as wedding lists or birthday lists</li>
     * <li>type - type of WishList. Ignored when set to a negative number. If not negative it will
     * match the listType attribute of the Wish List</li>
     * </ul>
     * <p>
     * The custom fields of the dataDesc object will also be used in the search if not set to null.
     * 
     * @param sessionId
     *            The session id of the logged in user. It may be null if the user isn't logged in.
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order
     * @param customerSearch
     *            Used to search for customers
     * @return Returns a WishListsIf object containing an array of wishList objects and paging
     *         information.
     * @throws KKException
     */
     public WishListsIf searchForWishLists(String sessionId, DataDescriptorIf dataDesc, CustomerSearchIf customerSearch) throws KKException
     {
         try
         {
            if (_searchForWishLists == null)
            {
                _searchForWishLists = new SearchForWishLists(kkEng);
            }

            return _searchForWishLists.searchForWishLists(sessionId, dataDesc, customerSearch);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the store that this KonaKart engine is connected to.
     * 
     * @return Returns a Store object or null if the store isn't found
     * @throws KKException
     */
     public StoreIf getStore() throws KKException
     {
         try
         {
            if (_getStore == null)
            {
                _getStore = new GetStore(kkEng);
            }

            return _getStore.getStore();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A sessionId is created when a customer logs in to KonaKart using the login() API call. This
     * sessionId is persisted in the database in a table which has 5 custom fields. This method
     * allows you to store data in these custom fields which can later be retrieved by using the
     * sessionId as the key.
     * 
     * @param sessionId
     *            The sessionId
     * @param data
     *            The data to be saved
     * @param position
     *            This must be in the range of 1-5 to identify custom1 to custom5
     * @throws KKException
     */
     public void addCustomDataToSession(String sessionId, String data, int position) throws KKException
     {
         try
         {
            if (_addCustomDataToSession == null)
            {
                _addCustomDataToSession = new AddCustomDataToSession(kkEng);
            }

            _addCustomDataToSession.addCustomDataToSession(sessionId, data, position);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A sessionId is created when a customer logs in to KonaKart using the login() API call. This
     * sessionId is persisted in the database in a table which has 5 custom fields. This method
     * allows you to retrieve the data in these custom fields by passing the sessionId as the key
     * and a pointer to identify the custom field to be used.
     * 
     * @param sessionId
     *            The sessionId
     * @param position
     *            This must be in the range of 1-5 to identify custom1 to custom5
     * @return Returns the custom data
     * @throws KKException
     */
     public String getCustomDataFromSession(String sessionId, int position) throws KKException
     {
         try
         {
            if (_getCustomDataFromSession == null)
            {
                _getCustomDataFromSession = new GetCustomDataFromSession(kkEng);
            }

            return _getCustomDataFromSession.getCustomDataFromSession(sessionId, position);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Saves the cookie in the database. If it already exists, it is edited.
     * <p>
     * The cookie object passed in as a parameter must have the following attributes set:
     * <ul>
     * <li>customerUuid</li>
     * <li>attributeId</li>
     * <li>attributeValue</li>
     * </ul>
     * <p>
     * The unique key for the cookie is the customerUuid together with the attributeId. The
     * customerUuid is the value that should be saved and retrieved from the browser cookie and then
     * used to look up the attributes saved in the KonaKart database. It can be created using the
     * java.util.UUID class.
     * 
     * @param cookie
     *            A KKCookie object to be persisted in the database
     * @throws KKException
     */
     public void setCookie(KKCookieIf cookie) throws KKException
     {
         try
         {
            if (_setCookie == null)
            {
                _setCookie = new SetCookie(kkEng);
            }

            _setCookie.setCookie(cookie);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Fetches the cookie object from the database that is referenced by the customerUuid and attrId
     * parameters. If the cookie object doesn't exist, null is returned.
     * <p>
     * When this method is called, the last_read date of the returned cookie in the database, is
     * updated.
     * 
     * @param customerUuid
     *            A random string used to identify the customer that owns the cookies
     * @param attrId
     *            An identifier for the cookie
     * @return Returns a KKCookie object
     * @throws KKException
     */
     public KKCookieIf getCookie(String customerUuid, String attrId) throws KKException
     {
         try
         {
            if (_getCookie == null)
            {
                _getCookie = new GetCookie(kkEng);
            }

            return _getCookie.getCookie(customerUuid, attrId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Fetches all of the cookie object from the database that are referenced by the customerUuid
     * parameter. If no cookies exist, an empty array is returned.
     * <p>
     * When this method is called, the last_read date for each returned cookies in the database, is
     * updated.
     * 
     * @param customerUuid
     *            A random string used to identify the customer that owns the cookies
     * @return Returns an array of KKCookie objects
     * @throws KKException
     */
     public KKCookieIf[] getAllCookies(String customerUuid) throws KKException
     {
         try
         {
            if (_getAllCookies == null)
            {
                _getAllCookies = new GetAllCookies(kkEng);
            }

            return _getAllCookies.getAllCookies(customerUuid);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Deletes the cookie object from the database that is referenced by the customerUuid and attrId
     * parameters.
     * 
     * @param customerUuid
     *            A random string used to identify the customer that owns the cookies
     * @param attrId
     *            An identifier for the cookie
     * @throws KKException
     */
     public void deleteCookie(String customerUuid, String attrId) throws KKException
     {
         try
         {
            if (_deleteCookie == null)
            {
                _deleteCookie = new DeleteCookie(kkEng);
            }

            _deleteCookie.deleteCookie(customerUuid, attrId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of GeoZone objects (tax areas) for the zone passed in as a parameter. There
     * may be multiple tax areas for a physical zone, which is why an array of GeoZone objects is
     * returned. An example of this is state tax and federal tax.
     * 
     * @param zone
     *            The physical zone
     * @return Return an array of GeoZone objects
     * @throws KKException
     */
     public GeoZoneIf[] getGeoZonesPerZone(ZoneIf zone) throws KKException
     {
         try
         {
            if (_getGeoZonesPerZone == null)
            {
                _getGeoZonesPerZone = new GetGeoZonesPerZone(kkEng);
            }

            return _getGeoZonesPerZone.getGeoZonesPerZone(zone);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Assigns a customer tag to the customer referenced by the <code>sessionId</code>.
     * <p>
     * If a tag already exists with this name, then the value is replaced with the new value. The
     * compulsory tag fields are:
     * <ul>
     * <li>name</li>
     * <li>value</li>
     * </ul>
     * <p>
     * Note that a customer tag with name <code>tag.getName()</code> must exist in the database
     * since it is used to validate <code>tag.getValue()</code>.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param tag
     *            Customer Tag
     * @throws KKException
     */
     public void insertCustomerTag(String sessionId, CustomerTagIf tag) throws KKException
     {
         try
         {
            if (_insertCustomerTag == null)
            {
                _insertCustomerTag = new InsertCustomerTag(kkEng);
            }

            _insertCustomerTag.insertCustomerTag(sessionId, tag);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Assigns a customer tag to the guest customer referenced by the <code>customerId</code> which
     * must have a negative value.
     * <p>
     * If a tag already exists with this name, then the value is replaced with the new value. The
     * compulsory tag fields are:
     * <ul>
     * <li>name</li>
     * <li>value</li>
     * </ul>
     * <p>
     * Note that a customer tag with name <code>tag.getName()</code> must exist in the database
     * since it is used to validate <code>tag.getValue()</code>.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param tag
     *            Customer Tag
     * @throws KKException
     */
     public void insertCustomerTagForGuest(int customerId, CustomerTagIf tag) throws KKException
     {
         try
         {
            if (_insertCustomerTagForGuest == null)
            {
                _insertCustomerTagForGuest = new InsertCustomerTagForGuest(kkEng);
            }

            _insertCustomerTagForGuest.insertCustomerTagForGuest(customerId, tag);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used for customer tags where the value is of type
     * <code>com.konakart.app.CustomerTag.MULTI_INT_TYPE</code>. This customer tag type is used to
     * store a series of integers and is useful for cases where you want to store information such
     * as the last 5 product ids that a customer looked at.
     * <p>
     * If the customer tag doesn't yet exist for the customer referenced by the
     * <code>sessionId</code>, then a new customer tag is added with the value in the
     * <code>tagValue</code> parameter. Otherwise the new value is added. When the number of
     * integers stored reaches the maximum value defined for the customer tag, then the new value is
     * added and the oldest value is removed.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param tagName
     *            Name of the customer tag
     * @param tagValue
     *            Value of the customer tag
     * @throws KKException
     */
     public void addToCustomerTag(String sessionId, String tagName, int tagValue) throws KKException
     {
         try
         {
            if (_addToCustomerTag == null)
            {
                _addToCustomerTag = new AddToCustomerTag(kkEng);
            }

            _addToCustomerTag.addToCustomerTag(sessionId, tagName, tagValue);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used for customer tags where the value is of type
     * <code>com.konakart.app.CustomerTag.MULTI_INT_TYPE</code>. This customer tag type is used to
     * store a series of integers and is useful for cases where you want to store information such
     * as the last 5 product ids that a customer looked at.
     * <p>
     * If the customer tag doesn't yet exist for the guest customer referenced by the
     * <code>customerId</code> (negative value), then a new customer tag is added with the value in
     * the <code>tagValue</code> parameter. Otherwise the new value is added. When the number of
     * integers stored reaches the maximum value defined for the customer tag, then the new value is
     * added and the oldest value is removed.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param tagName
     *            Name of the customer tag
     * @param tagValue
     *            Value of the customer tag
     * @throws KKException
     */
     public void addToCustomerTagForGuest(int customerId, String tagName, int tagValue) throws KKException
     {
         try
         {
            if (_addToCustomerTagForGuest == null)
            {
                _addToCustomerTagForGuest = new AddToCustomerTagForGuest(kkEng);
            }

            _addToCustomerTagForGuest.addToCustomerTagForGuest(customerId, tagName, tagValue);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A CustomerTag object referenced by the parameter <code>tagName</code> is returned. The value
     * attribute of the tag is populated for the customer referenced by the <code>sessionId</code>.
     * If <code>sessionId</code> is set to null, then a customer tag object with a null value is
     * returned.
     * <p>
     * The CustomerTag object contains utility methods to convert the tag string into its original
     * type (i.e. Date, boolean, int etc.).
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param tagName
     *            Name of the customer tag
     * @return Returns a CustomerTag object, populated with the value.
     * @throws KKException
     */
     public CustomerTagIf getCustomerTag(String sessionId, String tagName) throws KKException
     {
         try
         {
            if (_getCustomerTag == null)
            {
                _getCustomerTag = new GetCustomerTag(kkEng);
            }

            return _getCustomerTag.getCustomerTag(sessionId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A CustomerTag object referenced by the parameter <code>tagName</code> is returned. The value
     * attribute of the tag is populated for the guest customer referenced by the negative
     * <code>customerId</code>.
     * <p>
     * The CustomerTag object contains utility methods to convert the tag string into its original
     * type (i.e. Date, boolean, int etc.).
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param tagName
     *            Name of the customer tag
     * @return Returns a CustomerTag object, populated with the value.
     * @throws KKException
     */
     public CustomerTagIf getCustomerTagForGuest(int customerId, String tagName) throws KKException
     {
         try
         {
            if (_getCustomerTagForGuest == null)
            {
                _getCustomerTagForGuest = new GetCustomerTagForGuest(kkEng);
            }

            return _getCustomerTagForGuest.getCustomerTagForGuest(customerId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A string is returned containing the value of the customer tag referenced by the parameter
     * <code>tagName</code> and for the customer referenced by the <code>sessionId</code>. This
     * method is faster than the <code>getCustomerTag</code> method, but the actual CustomerTag
     * object isn't available to convert the String into a more usable form such as boolean or date.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param tagName
     *            Name of the customer tag
     * @return Returns a string containing the tag value
     * @throws KKException
     */
     public String getCustomerTagValue(String sessionId, String tagName) throws KKException
     {
         try
         {
            if (_getCustomerTagValue == null)
            {
                _getCustomerTagValue = new GetCustomerTagValue(kkEng);
            }

            return _getCustomerTagValue.getCustomerTagValue(sessionId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A string is returned containing the value of the customer tag referenced by the parameter
     * <code>tagName</code> and for the guest customer referenced by the negative
     * <code>customerId</code>. This method is faster than the <code>getCustomerTag</code> method,
     * but the actual CustomerTag object isn't available to convert the String into a more usable
     * form such as boolean or date.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param tagName
     *            Name of the customer tag
     * @return Returns a string containing the tag value
     * @throws KKException
     */
     public String getCustomerTagValueForGuest(int customerId, String tagName) throws KKException
     {
         try
         {
            if (_getCustomerTagValueForGuest == null)
            {
                _getCustomerTagValueForGuest = new GetCustomerTagValueForGuest(kkEng);
            }

            return _getCustomerTagValueForGuest.getCustomerTagValueForGuest(customerId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method deletes the customer tag referenced by the parameter <code>tagName</code> and for
     * the customer referenced by the <code>sessionId</code>.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param tagName
     *            Name of the customer tag
     * @throws KKException
     */
     public void deleteCustomerTag(String sessionId, String tagName) throws KKException
     {
         try
         {
            if (_deleteCustomerTag == null)
            {
                _deleteCustomerTag = new DeleteCustomerTag(kkEng);
            }

            _deleteCustomerTag.deleteCustomerTag(sessionId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method deletes the customer tag referenced by the parameter <code>tagName</code> and for
     * the guest customer referenced by the negative <code>customerId</code>.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param tagName
     *            Name of the customer tag
     * @throws KKException
     */
     public void deleteCustomerTagForGuest(int customerId, String tagName) throws KKException
     {
         try
         {
            if (_deleteCustomerTagForGuest == null)
            {
                _deleteCustomerTagForGuest = new DeleteCustomerTagForGuest(kkEng);
            }

            _deleteCustomerTagForGuest.deleteCustomerTagForGuest(customerId, tagName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method fetches all of the customer tags for the customer referenced by the
     * <code>sessionId</code>.
     * <p>
     * An empty array is returned if no tags exist.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Returns an array of CustomerTag objects
     * @throws KKException
     */
     public CustomerTagIf[] getCustomerTags(String sessionId) throws KKException
     {
         try
         {
            if (_getCustomerTags == null)
            {
                _getCustomerTags = new GetCustomerTags(kkEng);
            }

            return _getCustomerTags.getCustomerTags(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method fetches all of the customer tags for the guest customer referenced by the
     * <code>customerId</code> which must have a negative value.
     * <p>
     * An empty array is returned if no tags exist.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @return Returns an array of CustomerTag objects
     * @throws KKException
     */
     public CustomerTagIf[] getCustomerTagsForGuest(int customerId) throws KKException
     {
         try
         {
            if (_getCustomerTagsForGuest == null)
            {
                _getCustomerTagsForGuest = new GetCustomerTagsForGuest(kkEng);
            }

            return _getCustomerTagsForGuest.getCustomerTagsForGuest(customerId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An expression object is retrieved from the database and evaluated for the customer referenced
     * by the <code>sessionId</code>. If the <code>expressionName</code> parameter is not set to
     * null, then the Expression is searched for by name. Otherwise it is searched for by the id
     * contained in the <code>expressionId</code> parameter.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param expressionId
     *            Numeric Id of the expression
     * @param expressionName
     *            Name of expression
     * @return Returns true or false
     * @throws KKException
     */
     public boolean evaluateExpression(String sessionId, int expressionId, String expressionName) throws KKException
     {
         try
         {
            if (_evaluateExpression == null)
            {
                _evaluateExpression = new EvaluateExpression(kkEng);
            }

            return _evaluateExpression.evaluateExpression(sessionId, expressionId, expressionName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An expression object is retrieved from the database and evaluated for the guest customer
     * referenced by the negative <code>customerId</code>. If the <code>expressionName</code>
     * parameter is not set to null, then the Expression is searched for by name. Otherwise it is
     * searched for by the id contained in the <code>expressionId</code> parameter.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param expressionId
     *            Numeric Id of the expression
     * @param expressionName
     *            Name of expression
     * @return Returns true or false
     * @throws KKException
     */
     public boolean evaluateExpressionForGuest(int customerId, int expressionId, String expressionName) throws KKException
     {
         try
         {
            if (_evaluateExpressionForGuest == null)
            {
                _evaluateExpressionForGuest = new EvaluateExpressionForGuest(kkEng);
            }

            return _evaluateExpressionForGuest.evaluateExpressionForGuest(customerId, expressionId, expressionName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An Expression object, fully populated with an array of Expression Variables is returned. If
     * the <code>expressionName</code> parameter is not set to null, then the Expression is searched
     * for by name. Otherwise it is searched for by the id contained in the
     * <code>expressionId</code> parameter.
     * <p>
     * If the <code>sessionId</code> parameter is null we get the expression variables without any
     * customer tag values. Otherwise the expression variables will be populated with the customer
     * tag values for the customer referenced by <code>sessionId</code>. other
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param expressionId
     *            Numeric Id of the expression
     * @param expressionName
     *            Name of expression
     * @return Returns a fully populated Expression object
     * @throws KKException
     */
     public ExpressionIf getExpression(String sessionId, int expressionId, String expressionName) throws KKException
     {
         try
         {
            if (_getExpression == null)
            {
                _getExpression = new GetExpression(kkEng);
            }

            return _getExpression.getExpression(sessionId, expressionId, expressionName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An Expression object, fully populated with an array of Expression Variables is returned. If
     * the <code>expressionName</code> parameter is not set to null, then the Expression is searched
     * for by name. Otherwise it is searched for by the id contained in the
     * <code>expressionId</code> parameter.
     * <p>
     * The expression variables will be populated with the customer tag values for the guest
     * customer referenced by <code>customerId</code>.
     * 
     * @param customerId
     *            The id of the guest customer which has a negative value.
     * @param expressionId
     *            Numeric Id of the expression
     * @param expressionName
     *            Name of expression
     * @return Returns a fully populated Expression object
     * @throws KKException
     */
     public ExpressionIf getExpressionForGuest(int customerId, int expressionId, String expressionName) throws KKException
     {
         try
         {
            if (_getExpressionForGuest == null)
            {
                _getExpressionForGuest = new GetExpressionForGuest(kkEng);
            }

            return _getExpressionForGuest.getExpressionForGuest(customerId, expressionId, expressionName);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Calculates the number of reward points available for the customer identified by the
     * <code>sessionId</code> parameter.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Returns the number of points available for spending
     * @throws KKException
     */
     public int pointsAvailable(String sessionId) throws KKException
     {
         try
         {
            if (_pointsAvailable == null)
            {
                _pointsAvailable = new PointsAvailable(kkEng);
            }

            return _pointsAvailable.pointsAvailable(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Adds a number of reward points to the total for customer identified by the
     * <code>sessionId</code> parameter.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param points
     *            Number of points to add
     * @param code
     *            An optional code to categorize the reason for awarding the points
     * @param description
     *            An optional description describing why the points were awarded
     * @return Returns the new number of points available for spending
     * @throws KKException
     */
     public int addPoints(String sessionId, int points, String code, String description) throws KKException
     {
         try
         {
            if (_addPoints == null)
            {
                _addPoints = new AddPoints(kkEng);
            }

            return _addPoints.addPoints(sessionId, points, code, description);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Deletes a number of reward points from the total for the customer identified by the
     * <code>sessionId</code> parameter.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param points
     *            Number of points to delete
     * @param code
     *            An optional code to categorize the reason for redeeming the points
     * @param description
     *            An optional description describing how the points were redeemed
     * @return Returns the new number of points available for spending
     * @throws KKException
     */
     public int deletePoints(String sessionId, int points, String code, String description) throws KKException
     {
         try
         {
            if (_deletePoints == null)
            {
                _deletePoints = new DeletePoints(kkEng);
            }

            return _deletePoints.deletePoints(sessionId, points, code, description);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Removes a number of reward points from the total for the customer identified by the
     * <code>sessionId</code> parameter. The removed points are not deleted but reserved, so that
     * they are no longer available for spending but may be deleted once the order has been paid for
     * or shipped. If the order is never fulfilled, then the reserved points may be freed and
     * returned to the available total.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param points
     *            Number of points to reserve
     * @return Returns the reservation id of the reserved points
     * @throws KKException
     */
     public int reservePoints(String sessionId, int points) throws KKException
     {
         try
         {
            if (_reservePoints == null)
            {
                _reservePoints = new ReservePoints(kkEng);
            }

            return _reservePoints.reservePoints(sessionId, points);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Verifies that the <code>reservationId</code> parameter exists and that it belongs to the
     * customer identified by the <code>sessionId</code> parameter. The reserved points are normally
     * deleted once the order has been paid for or shipped. If the order is never fulfilled, then
     * the reserved points may be freed and returned to the available total. Once deleted. the
     * points can no longer be returned to the total.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param reservationId
     *            Numeric identifier of the reservation
     * @param code
     *            An optional code to categorize the reason for redeeming the points
     * @param description
     *            An optional description describing how the points were redeemed
     * @throws KKException
     */
     public void deleteReservedPoints(String sessionId, int reservationId, String code, String description) throws KKException
     {
         try
         {
            if (_deleteReservedPoints == null)
            {
                _deleteReservedPoints = new DeleteReservedPoints(kkEng);
            }

            _deleteReservedPoints.deleteReservedPoints(sessionId, reservationId, code, description);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Verifies that the <code>reservationId</code> parameter exists and that it belongs to the
     * customer identified by the <code>sessionId</code> parameter. The reserved points may be freed
     * and returned to the available total using this API call. The method checks to see whether
     * some or all of the points have expired while they were in the reserved state.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param reservationId
     *            Numeric identifier of the reservation
     * @return Returns the number of points available for spending
     * @throws KKException
     */
     public int freeReservedPoints(String sessionId, int reservationId) throws KKException
     {
         try
         {
            if (_freeReservedPoints == null)
            {
                _freeReservedPoints = new FreeReservedPoints(kkEng);
            }

            return _freeReservedPoints.freeReservedPoints(sessionId, reservationId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Verifies that the order belongs to the customer identified by the <code>sessionId</code>
     * parameter and then updates the reservation id on the order.
     * 
     * @param sessionId
     * @param orderId
     * @param reservationId
     * @throws KKException
     */
     public void setRewardPointReservationId(String sessionId, int orderId, int reservationId) throws KKException
     {
         try
         {
            if (_setRewardPointReservationId == null)
            {
                _setRewardPointReservationId = new SetRewardPointReservationId(kkEng);
            }

            _setRewardPointReservationId.setRewardPointReservationId(sessionId, orderId, reservationId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets an array of reward point objects for a customer identified by the <code>sessionId</code>
     * parameter. The most recent objects are returned first. The options object allows you to
     * define whether to return expired points.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset and limit the number of items returned
     * @param options
     *            Allows you to define whether to return expired points
     * @return Returns a RewardPoints object
     * @throws KKException
     */
     public RewardPointsIf getRewardPointsWithOptions(String sessionId, DataDescriptorIf dataDesc, FetchRewardPointOptionsIf options) throws KKException
     {
         try
         {
            if (_getRewardPointsWithOptions == null)
            {
                _getRewardPointsWithOptions = new GetRewardPointsWithOptions(kkEng);
            }

            return _getRewardPointsWithOptions.getRewardPointsWithOptions(sessionId, dataDesc, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Gets an array of reward point objects for a customer identified by the <code>sessionId</code>
     * parameter. The most recent objects are returned first.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset and limit the number of items returned
     * @return Returns a RewardPoints object
     * @throws KKException
     */
     public RewardPointsIf getRewardPoints(String sessionId, DataDescriptorIf dataDesc) throws KKException
     {
         try
         {
            if (_getRewardPoints == null)
            {
                _getRewardPoints = new GetRewardPoints(kkEng);
            }

            return _getRewardPoints.getRewardPoints(sessionId, dataDesc);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A Subscription object is inserted into the database. The following subscription attributes
     * are compulsory:
     * <ul>
     * <li>A valid orderId belonging to the customer referenced by the sessionId</li>
     * <li>A valid productId</li>
     * <li>A valid paymentScheduleId</li>
     * <li>Amount</li>
     * </ul>
     * The customer id of the Subscription object is fetched from the sessionId. The id of the new
     * object is returned.<br/>
     * The methods:
     * <ul>
     * <li>beforeInsertSubscription()</li>
     * <li>afterInsertSubscription</li>
     * </ul>
     * of the OrderIntegrationMgr are called before and after the insert to allow code to be
     * inserted that calls a payment gateway.<br>
     * The subscription may have an attached CreditCard object. The data within this object will not
     * be persisted in the database but will be passed to the code that communicates with the
     * payment gateway so that it can be transmitted and stored by the payment gateway.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param subscription
     *            The subscription object to be inserted
     * @return Returns the id of the Subscription object
     * @throws KKException
     */
     public int insertSubscription(String sessionId, SubscriptionIf subscription) throws KKException
     {
         try
         {
            if (_insertSubscription == null)
            {
                _insertSubscription = new InsertSubscription(kkEng);
            }

            return _insertSubscription.insertSubscription(sessionId, subscription);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A Subscription object identified by the subscription passed in as a parameter is updated in
     * the database. A check is made to ensure that the subscription belongs to the customer
     * identified by the sessionId. The methods:
     * <ul>
     * <li>beforeUpdateSubscription()</li>
     * <li>afterUpdateSubscription</li>
     * </ul>
     * of the OrderIntegrationMgr are called before and after the update to allow code to be
     * inserted that calls a payment gateway.<br>
     * The subscription may have an attached CreditCard object. The data within this object will not
     * be persisted in the database but will be passed to the code that communicates with the
     * payment gateway so that it can be transmitted and stored by the payment gateway. A common
     * reason for updating a subscription is actually to update the credit card details for the
     * subscription since the original card may have expired.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param subscription
     *            The subscription object to be updated
     * @throws KKException
     */
     public void updateSubscription(String sessionId, SubscriptionIf subscription) throws KKException
     {
         try
         {
            if (_updateSubscription == null)
            {
                _updateSubscription = new UpdateSubscription(kkEng);
            }

            _updateSubscription.updateSubscription(sessionId, subscription);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the payment schedule object for the <code>id</code> parameter, or Null if the payment
     * schedule object doesn't exist in the DB.
     * 
     * @param id
     *            The id of the payment schedule object
     * @return Returns a payment schedule object
     * @throws KKException
     */
     public PaymentScheduleIf getPaymentSchedule(int id) throws KKException
     {
         try
         {
            if (_getPaymentSchedule == null)
            {
                _getPaymentSchedule = new GetPaymentSchedule(kkEng);
            }

            return _getPaymentSchedule.getPaymentSchedule(id);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of Subscription objects for a customer referred to by the sessionId
     * parameter.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @return Returns an array of Subscription objects
     * @throws KKException
     */
     public SubscriptionIf[] getSubscriptionsPerCustomer(String sessionId) throws KKException
     {
         try
         {
            if (_getSubscriptionsPerCustomer == null)
            {
                _getSubscriptionsPerCustomer = new GetSubscriptionsPerCustomer(kkEng);
            }

            return _getSubscriptionsPerCustomer.getSubscriptionsPerCustomer(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieve a number of subscriptions for the customer referenced by the <code>sessionId</code>.
     * The SubscriptionSearch class contains the search criteria although it may be null.
     * <p>
     * <code>dataDesc</code> may be null. In this case, the number of retrieved subscriptions is
     * limited to a default number, the subscriptions are ordered by the SubscriptionId and the
     * offset is set to zero. However, by setting the attributes of <code>dataDesc</code>, the
     * following functionality may be controlled :
     * <ul>
     * <li>The maximum number of Subscription objects returned.</li>
     * <li>The offset which defaults to zero. This is useful when there are many Subscription
     * objects, in order to return them using multiple calls to this method.</li>
     * <li>Criteria on the custom attributes. If a custom attribute is set then only subscriptions
     * with a matching custom attribute value are returned.</li>
     * <li>The Subscriptions may be sorted by :
     * <ul>
     * <li>DataDescConstants.ORDER_BY_START_DATE_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_START_DATE_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ORDER_NUMBER_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ORDER_NUMBER_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM3_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM4_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_CUSTOM5_DESCENDING</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort
     * @param subscriptionSearch
     *            Contains information used to add search constraints
     * @return A Subscriptions object
     * @throws KKException
     */
     public SubscriptionsIf searchForSubscriptionsPerCustomer(String sessionId, DataDescriptorIf dataDesc, SubscriptionSearchIf subscriptionSearch) throws KKException
     {
         try
         {
            if (_searchForSubscriptionsPerCustomer == null)
            {
                _searchForSubscriptionsPerCustomer = new SearchForSubscriptionsPerCustomer(kkEng);
            }

            return _searchForSubscriptionsPerCustomer.searchForSubscriptionsPerCustomer(sessionId, dataDesc, subscriptionSearch);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get a product from its SKU. If the SKU refers to a particular configuration of the product
     * (i.e. Blue shirt, size small) then the product object is only populated with the options that
     * match the SKU and with the ProductQuantity object that matches the SKU. When a product is
     * retrieved based on its id or when the SKU is for a product without attributes, then all of
     * the options and product quantities are populated.
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param sku
     *            The product SKU
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns the product matching the SKU or null if no product is found
     * @throws KKException
     */
     public ProductIf getProductPerSkuWithOptions(String sessionId, String sku, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductPerSkuWithOptions == null)
            {
                _getProductPerSkuWithOptions = new GetProductPerSkuWithOptions(kkEng);
            }

            return _getProductPerSkuWithOptions.getProductPerSkuWithOptions(sessionId, sku, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get a product from its SKU. If the SKU refers to a particular configuration of the product
     * (i.e. Blue shirt, size small) then the product object is only populated with the options that
     * match the SKU and with the ProductQuantity object that matches the SKU. When a product is
     * retrieved based on its id or when the SKU is for a product without attributes, then all of
     * the options and product quantities are populated.
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param sku
     *            The product SKU
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @return Returns the product matching the SKU or null if no product is found
     * @throws KKException
     */
     public ProductIf getProductPerSku(String sessionId, String sku, int languageId) throws KKException
     {
         try
         {
            if (_getProductPerSku == null)
            {
                _getProductPerSku = new GetProductPerSku(kkEng);
            }

            return _getProductPerSku.getProductPerSku(sessionId, sku, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieve an array of IpnHistory objects for an order. The order must belong to the customer
     * referenced by the sessionId.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @return Returns an array of IpnHistory objects for the order
     * @throws KKException
     */
     public IpnHistoryIf[] getIpnHistory(String sessionId, int orderId) throws KKException
     {
         try
         {
            if (_getIpnHistory == null)
            {
                _getIpnHistory = new GetIpnHistory(kkEng);
            }

            return _getIpnHistory.getIpnHistory(sessionId, orderId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Creates a PDF document. For the case where the options object points to an order, the method
     * ensures that the order belongs to the customer referenced by the sessionId.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param options
     *            The PdfOptions object that defines the PDF document to create
     * @return Returns a PdfResult object
     * @throws KKException
     */
     public PdfResultIf getPdf(String sessionId, PdfOptionsIf options) throws KKException
     {
         try
         {
            if (_getPdf == null)
            {
                _getPdf = new GetPdf(kkEng);
            }

            return _getPdf.getPdf(sessionId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a Digital Download object for the digital download id. Returns null if no object
     * exists. A check is made to verify that the digital download object belongs to the customer
     * identified by the sessionId.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param digitalDownloadId
     *            The numeric id of the digital download object
     * @return Returns a DigitalDownload object
     * @throws KKException
     */
     public DigitalDownloadIf getDigitalDownloadById(String sessionId, int digitalDownloadId) throws KKException
     {
         try
         {
            if (_getDigitalDownloadById == null)
            {
                _getDigitalDownloadById = new GetDigitalDownloadById(kkEng);
            }

            return _getDigitalDownloadById.getDigitalDownloadById(sessionId, digitalDownloadId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Edits the digital download object if it belongs to the customer identified by the sessionId.
     * Otherwise an exception is thrown.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param digitalDownload
     *            The digital download object to be edited
     * @throws KKException
     */
     public void editDigitalDownload(String sessionId, DigitalDownloadIf digitalDownload) throws KKException
     {
         try
         {
            if (_editDigitalDownload == null)
            {
                _editDigitalDownload = new EditDigitalDownload(kkEng);
            }

            _editDigitalDownload.editDigitalDownload(sessionId, digitalDownload);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get an Application Message Value. If locale is null, the default locale is used.
     * 
     * @param key
     *            the message key
     * @param type
     *            the message type (should use KKConstants.MSG_TYP_APPLICATION for application
     *            messages)
     * @param locale
     *            the message locale (eg. "en_GB"). Default is used if left null.
     * @return The message for the key, type and locale. If the message isn't found the String
     *         "[key:type:locale]" is returned.
     * @throws KKException
     */
     public String getMsgValue(String key, int type, String locale) throws KKException
     {
         try
         {
            if (_getMsgValue == null)
            {
                _getMsgValue = new GetMsgValue(kkEng);
            }

            return _getMsgValue.getMsgValue(key, type, locale);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Used to fetch a message catalog for a locale and message type. If locale is null, the default
     * locale is used.
     * 
     * @param type
     *            the message type (should use KKConstants.MSG_TYP_APPLICATION for application
     *            messages)
     * @param locale
     *            the message locale (eg. "en_GB"). Default is used if left null.
     * @return Returns and array of NameValue objects containing the message catalog
     * @throws KKException
     */
     public NameValueIf[] getMessages(int type, String locale) throws KKException
     {
         try
         {
            if (_getMessages == null)
            {
                _getMessages = new GetMessages(kkEng);
            }

            return _getMessages.getMessages(type, locale);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Post a message to a specified queue. Use the options parameter to define the message text,
     * credentials and the destination queue.
     * 
     * @param sessionId
     *            the sessionId
     * @param options
     *            the MQ options
     * @throws KKException
     */
     public void postMessageToQueue(String sessionId, MqOptionsIf options) throws KKException
     {
         try
         {
            if (_postMessageToQueue == null)
            {
                _postMessageToQueue = new PostMessageToQueue(kkEng);
            }

            _postMessageToQueue.postMessageToQueue(sessionId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Read a single message from a specified queue. Use the options parameter to define
     * credentials, a timeout value and the name of the queue to read.
     * 
     * @param sessionId
     *            the sessionId
     * @param options
     *            the MQ options
     * @return an object describing the response from this call. Usually it will contain the text of
     *         the message that was read, but if there was a timeout the message will be null and
     *         the timedout attribute will be true.
     * @throws KKException
     */
     public MqResponseIf readMessageFromQueue(String sessionId, MqOptionsIf options) throws KKException
     {
         try
         {
            if (_readMessageFromQueue == null)
            {
                _readMessageFromQueue = new ReadMessageFromQueue(kkEng);
            }

            return _readMessageFromQueue.readMessageFromQueue(sessionId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The customer event is written to a queue and control is immediately returned to the caller.
     * The queue is emptied by a thread that persists the event to the database. The database where
     * the event is stored is defined in the properties file and for performance reasons may be
     * different to the database containing the standard KonaKart tables.
     * <p>
     * The DateAdded attribute of the event object is added by the engine if left null. The storeId
     * attribute of the event object is added by the engine.
     * 
     * @param event
     *            A customer event object
     * @throws KKException
     */
     public void insertCustomerEvent(CustomerEventIf event) throws KKException
     {
         try
         {
            if (_insertCustomerEvent == null)
            {
                _insertCustomerEvent = new InsertCustomerEvent(kkEng);
            }

            _insertCustomerEvent.insertCustomerEvent(event);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An array of SuggestedSearchItems is returned for search text within the options parameter.
     * This method is useful for creating a dynamic search entry field that shows a list of
     * suggested search items every time a character is entered in the search entry field.
     * 
     * @param sessionId
     *            the sessionId which may be left null if the customer isn't logged in
     * @param options
     *            A SuggestedSearchOptions object containing all parameters necessary to configure
     *            the SuggestedSearch operation
     * @return Returns an array of SuggestedSearchItems
     * @throws KKException
     */
     public SuggestedSearchItemIf[] getSuggestedSearchItems(String sessionId, SuggestedSearchOptionsIf options) throws KKException
     {
         try
         {
            if (_getSuggestedSearchItems == null)
            {
                _getSuggestedSearchItems = new GetSuggestedSearchItems(kkEng);
            }

            return _getSuggestedSearchItems.getSuggestedSearchItems(sessionId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An array of SuggestedSpellingItems is returned for search text within the options parameter.
     * This method is useful for prompting a customer with a list of alternative spellings contained
     * within the catalog if a search returns no results.
     * 
     * @param sessionId
     *            the sessionId which may be left null if the customer isn't logged in
     * @param options
     *            A SuggestedSpellingOptions object containing all parameters necessary to configure
     *            the SuggestedSpelling operation
     * @return Returns an array of SuggestedSpellingItems
     * @throws KKException
     */
     public SuggestedSpellingItemIf[] getSuggestedSpellingItems(String sessionId, SuggestedSpellingOptionsIf options) throws KKException
     {
         try
         {
            if (_getSuggestedSpellingItems == null)
            {
                _getSuggestedSpellingItems = new GetSuggestedSpellingItems(kkEng);
            }

            return _getSuggestedSpellingItems.getSuggestedSpellingItems(sessionId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * An array of products is returned that corresponds to an array of productIds passed in as a
     * parameter. The dataDesc parameter may be used to sort the products and to determine whether
     * to return the description and the options parameter may be used for advanced functionality
     * such as determining where to read the price and quantity information from.
     * 
     * @param sessionId
     *            The session id of the logged in user; use null if the customer isn't logged in.
     * @param dataDesc
     *            Can be used to add sort by information and to set whether to return the
     *            description of the products.
     * @param prodIdArray
     *            An array of product ids
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns an array of products
     * @throws KKException
     */
     public ProductIf[] getProductsFromIdsWithOptions(String sessionId, DataDescriptorIf dataDesc, int[] prodIdArray, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductsFromIdsWithOptions == null)
            {
                _getProductsFromIdsWithOptions = new GetProductsFromIdsWithOptions(kkEng);
            }

            return _getProductsFromIdsWithOptions.getProductsFromIdsWithOptions(sessionId, dataDesc, prodIdArray, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get an array of bookings for a bookable product. The DatDescriptor object may be used to add
     * constraints on the custom fields and to add order by criteria. The following OrderBy criteria
     * are implemented:
     * <ul>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_FIRST_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_FIRST_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_LAST_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_LAST_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * </ul>
     * 
     * @param dataDesc
     *            Can be used to add sort by information and constraints on the custom fields
     * @param productId
     *            The numeric id of the product
     * @param options
     *            Not used at the moment. May be left null.
     * @return Returns a Bookings object containing the bookings
     * @throws KKException
     */
     public BookingsIf getBookingsPerProduct(DataDescriptorIf dataDesc, int productId, BookableProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBookingsPerProduct == null)
            {
                _getBookingsPerProduct = new GetBookingsPerProduct(kkEng);
            }

            return _getBookingsPerProduct.getBookingsPerProduct(dataDesc, productId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get an array of bookings for a logged in customer. The DataDescriptor object may be used to
     * add constraints on the custom fields and to add order by criteria. The following OrderBy
     * criteria are implemented:
     * <ul>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_FIRST_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_FIRST_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_LAST_NAME_DESCENDING</li>
     * <li>DataDescConstants.ORDER_BY_LAST_NAME_ASCENDING</li>
     * <li>DataDescConstants.ORDER_BY_ID</li>
     * </ul>
     * 
     * @param sessionId
     *            The sessionId of the logged in customer
     * @param dataDesc
     *            Can be used to add sort by information and constraints on the custom fields
     * @param options
     *            Not used at the moment. May be left null.
     * @return Returns a Bookings object
     * @throws KKException
     */
     public BookingsIf getBookingsPerCustomer(String sessionId, DataDescriptorIf dataDesc, BookableProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBookingsPerCustomer == null)
            {
                _getBookingsPerCustomer = new GetBookingsPerCustomer(kkEng);
            }

            return _getBookingsPerCustomer.getBookingsPerCustomer(sessionId, dataDesc, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Inserts a Booking object into the database. The customer must be logged in with a valid
     * session id. The id of the logged in customer is written into the customerId attribute of the
     * Booking object before it is saved. The Booking must be associated with an existing product
     * through the productId attribute.
     * 
     * @param sessionId
     *            The sessionId of the logged in customer
     * @param booking
     *            A booking object
     * @param options
     *            Options allowing an exception to be thrown for exceeding the maximum number of
     *            bookings
     * @return Returns the id of the inserted object
     * @throws KKException
     */
     public int insertBooking(String sessionId, BookingIf booking, BookableProductOptionsIf options) throws KKException
     {
         try
         {
            if (_insertBooking == null)
            {
                _insertBooking = new InsertBooking(kkEng);
            }

            return _insertBooking.insertBooking(sessionId, booking, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method checks to see whether the bookable product passed in as a parameter conflicts
     * with any bookable products that the customer identified by the sessionId has already signed
     * up for.<br>
     * If no conflicts are found, null is returned. If a conflict is found then an array of
     * conflicting bookable products is returned.
     * 
     * @param sessionId
     *            The sessionId of the logged in customer
     * @param bookableProd
     *            The bookable product being checked
     * @param options
     *            Not used at the moment. May be left null.
     * @return Returns null for no conflict. Otherwise an array of conflicting products is returned.
     * @throws KKException
     */
     public ProductIf[] getBookableProductConflict(String sessionId, ProductIf bookableProd, BookableProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBookableProductConflict == null)
            {
                _getBookableProductConflict = new GetBookableProductConflict(kkEng);
            }

            return _getBookableProductConflict.getBookableProductConflict(sessionId, bookableProd, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get the order status for an order. The order doesn't have to belong to the logged in
     * customer.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param orderId
     *            The numeric id of the order
     * @return Returns the order status. Returns -1 if the order doesn't exist.
     * @throws KKException
     */
     public int getOrderStatus(String sessionId, int orderId) throws KKException
     {
         try
         {
            if (_getOrderStatus == null)
            {
                _getOrderStatus = new GetOrderStatus(kkEng);
            }

            return _getOrderStatus.getOrderStatus(sessionId, orderId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of order status objects for the language defined by languageId.
     * 
     * @param languageId
     *            The id for the language that will be used to determine the customer group name and
     *            description. Value of -1 selects the default language.
     * @return An array of order status objects.
     * @throws KKException
     */
     public OrderStatusIf[] getAllOrderStatuses(int languageId) throws KKException
     {
         try
         {
            if (_getAllOrderStatuses == null)
            {
                _getAllOrderStatuses = new GetAllOrderStatuses(kkEng);
            }

            return _getAllOrderStatuses.getAllOrderStatuses(languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Saves the SSOToken in the database and returns a UUID secret key identifier.
     * 
     * @param token
     *            The SSO token to be saved
     * @return Returns a UUID secret key identifier for the token
     * @throws KKException
     */
     public String saveSSOToken(SSOTokenIf token) throws KKException
     {
         try
         {
            if (_saveSSOToken == null)
            {
                _saveSSOToken = new SaveSSOToken(kkEng);
            }

            return _saveSSOToken.saveSSOToken(token);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an SSOToken object for the secretKey (UUID). Null is returned if no token is found.
     * If the <code>deleteToken</code> parameter is set to true, the token is deleted from the
     * database after having been read.
     * 
     * @param secretKey
     *            The UUID secretKey used to identify the token
     * @param deleteToken
     *            The token is deleted from the database after being read
     * @return Returns an SSOToken
     * @throws KKException
     */
     public SSOTokenIf getSSOToken(String secretKey, boolean deleteToken) throws KKException
     {
         try
         {
            if (_getSSOToken == null)
            {
                _getSSOToken = new GetSSOToken(kkEng);
            }

            return _getSSOToken.getSSOToken(secretKey, deleteToken);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method reads the SSO token using the Secret Key. Once read, the token is deleted. The
     * customer id read from the token is used to identify and enable the customer. An exception is
     * thrown if a customer doesn't exist for the customer id found in the token.<br>
     * This method is normally used to verify a customer's email before enabling a customer. i.e.
     * When the customer registers, the registration is made but the customer remains disabled. An
     * SSO token is saved containing the id of the new customer. At this point an eMail is sent to
     * the customer, prompting him to click on a link containing the SSO token secret key. The link
     * calls an application method that uses the secret key to enable the customer by calling this
     * API call.
     * 
     * @param secretKey
     * @throws KKException
     */
     public void enableCustomer(String secretKey) throws KKException
     {
         try
         {
            if (_enableCustomer == null)
            {
                _enableCustomer = new EnableCustomer(kkEng);
            }

            _enableCustomer.enableCustomer(secretKey);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used to verify whether a coupon code actually exists and if it does, whether
     * the coupon is still active. Valid return values for this method are:
     * <ul>
     * <li>com.konakart.bl.PromotionMgr.COUPON_DOESNT_EXIST - The coupon code does not exist.</li>
     * <li>com.konakart.bl.PromotionMgr.COUPON_EXISTS_ACTIVE - The coupon code does exist and the
     * coupon is still active.</li>
     * <li>com.konakart.bl.PromotionMgr.COUPON_EXISTS_INACTIVE - The coupon code does exist but the
     * coupon is no longer active since the number of times it has been used has reached the maximum
     * number of times allowed.</li>
     * </ul>
     * Even if the coupon exists and is active, it won't actually do anything if it isn't connected
     * to a valid promotion and any rules associated with the promotion are also satisfied. However,
     * this method may still be used to at least warn a customer that he may have mistyped the
     * coupon code or that it is no longer valid.
     * 
     * @param couponCode
     *            The coupon code
     * @return Returns an integer
     * @throws KKException
     */
     public int checkCoupon(String couponCode) throws KKException
     {
         try
         {
            if (_checkCoupon == null)
            {
                _checkCoupon = new CheckCoupon(kkEng);
            }

            return _checkCoupon.checkCoupon(couponCode);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of all active promotions. If a promotion is disabled or the current date is
     * not within the start and end dates of the promotion, then it is not returned. Also if an
     * OrderTotal module is not installed, then none of the promotions for that OrderTotal module
     * are returned.
     * 
     * @return Returns an array of all active promotions
     * @throws KKException
     */
     public PromotionIf[] getAllPromotions() throws KKException
     {
         try
         {
            if (_getAllPromotions == null)
            {
                _getAllPromotions = new GetAllPromotions(kkEng);
            }

            return _getAllPromotions.getAllPromotions();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used to calculate a discount on individual products so that the discount can
     * be displayed without having to add the product to the cart.<br>
     * The method receives an array of products and returns an array of products with attached
     * PromotionResult objects that contain the results of one or more of the promotions passed in
     * as a parameter. The PromotionResult contains the value of the discount, whether it is an
     * amount or a percentage discount and also information regarding the promotion it applies to.
     * If a product has an array of ProductQuantity objects (one for each SKU) each one of these may
     * have an array of PromotionResult objects since a promotion may only apply to one product
     * configuration and not to another (i.e. blue shirt and not red shirt).<br>
     * The PromotionOptions object can be configured so that the values of the promotions for a
     * product are subtracted from the product price. The options allow you to set rules that
     * determine whether in this case the promotions need to be cumulative or whether the largest or
     * smallest should be chosen. The calculation is only made for products with a single array of
     * PromotionResult objects. It is not calculated for products that have an array of
     * PromotionResult objects for each ProductQuantity.
     * 
     * @param sessionId
     *            Only used if the customer is logged in. Otherwise set to null.
     * @param customerId
     *            If the sessionId is set to null then the customerId should contain the id of the
     *            temporary user which is a negative number. The temporary user id can be used for
     *            evaluating expression rules.
     * @param products
     *            An array of products to be processed
     * @param promotions
     *            The promotions which will be applied to the products if all rules are matched.
     * @param couponCodes
     *            Coupon codes to use. If none of the promotions require coupons, it should be set
     *            to null
     * @param options
     *            An object containing information to configure the calculation for applying one or
     *            more promotion results to the product price.
     * @return Returns the same array of products passed in as a parameter with attached
     *         PromotionResult objects if applicable
     * @throws KKException
     */
     public ProductIf[] getPromotionsPerProducts(String sessionId, int customerId, ProductIf[] products, PromotionIf[] promotions, String[] couponCodes, PromotionOptionsIf options) throws KKException
     {
         try
         {
            if (_getPromotionsPerProducts == null)
            {
                _getPromotionsPerProducts = new GetPromotionsPerProducts(kkEng);
            }

            return _getPromotionsPerProducts.getPromotionsPerProducts(sessionId, customerId, products, promotions, couponCodes, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the ConfigData items with the specified key or all ConfigData items if the key is
     * null
     * 
     * @param sessionId
     *            Session Id of the customer.
     * @param key
     *            Only return the ConfigData items with this key (if null all ConfigData items are
     *            returned)
     * @return Returns an array of ConfigData items with the specified key or all ConfigData items
     *         if the key is null ordered by date added
     * @throws KKException
     */
     public ConfigDataIf[] getConfigData(String sessionId, String key) throws KKException
     {
         try
         {
            if (_getConfigData == null)
            {
                _getConfigData = new GetConfigData(kkEng);
            }

            return _getConfigData.getConfigData(sessionId, key);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return the version number of KonaKart that is contained within the konakart.jar
     * 
     * @return the KonaKart version number as a String in the form N.N.N.N
     * @throws KKException
     */
     public String getKonaKartVersion() throws KKException
     {
         try
         {
            if (_getKonaKartVersion == null)
            {
                _getKonaKartVersion = new GetKonaKartVersion(kkEng);
            }

            return _getKonaKartVersion.getKonaKartVersion();
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Creates a punch out message from an order. The options parameter defines the standard used.
     * Valid standards are:
     * <ul>
     * <li>com.konakart.app.PunchOutOptions.OCI_HTML - OCI standard using HTML messages</li>
     * <li>com.konakart.app.PunchOutOptions.OCI_XML - OCI standard using XML messages</li>
     * </ul>
     * 
     * @param sessionId
     *            Session Id of the customer.
     * @param order
     *            Order used to create message
     * @param options
     *            Options to configure the call by defining things such as the standard used for the
     *            message and the version of the standard.
     * @return Returns the message used for the punch out in the form of a string (normally XML) or
     *         an array of name value pairs, all contained within a PunchOutResult object.
     * @throws KKException
     */
     public PunchOutResultIf getPunchOutMessage(String sessionId, OrderIf order, PunchOutOptionsIf options) throws KKException
     {
         try
         {
            if (_getPunchOutMessage == null)
            {
                _getPunchOutMessage = new GetPunchOutMessage(kkEng);
            }

            return _getPunchOutMessage.getPunchOutMessage(sessionId, order, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A method that allows you sign up a customer for a newsletter or product notification. The
     * customer may be registered or non registered. The parameters are contained within the
     * NotificationOptions object and function as follows:
     * <ol>
     * <li>If sessionId is not null, it will be checked and the identity of the customer will be
     * retrieved from the sessionId.</li>
     * <li>If customerId is set to a positive value, it will be used to identify the customer. If
     * the id is that of a registered customer, then a KKException is thrown. In this case the user
     * must be logged in and the sessionId parameter must be set to a valid value.</li>
     * <li>If emailAddr is not null then it is used to sign up the customer. If the email address
     * belongs to a registered customer, then a KKException is thrown. In this case the user must be
     * logged in and the sessionId parameter must be set to a valid value.</li>
     * </ol>
     * Note that the above parameters are exclusive and will be processed in the order displayed.
     * 
     * @param options
     *            Contains the method parameters.
     * @throws KKException
     */
     public void addCustomerNotifications(NotificationOptionsIf options) throws KKException
     {
         try
         {
            if (_addCustomerNotifications == null)
            {
                _addCustomerNotifications = new AddCustomerNotifications(kkEng);
            }

            _addCustomerNotifications.addCustomerNotifications(options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * A method that allows you remove a customer notification for a newsletter or product. The
     * customer may be registered or non registered. The parameters are contained within the
     * NotificationOptions object and function as follows:
     * <ol>
     * <li>If sessionId is not null, it will be checked and the identity of the customer will be
     * retrieved from the sessionId.</li>
     * <li>If customerId is set to a positive value, it will be used to identify the customer. If
     * the id is that of a registered customer, then a KKException is thrown. In this case the user
     * must be logged in and the sessionId parameter must be set to a valid value.</li>
     * <li>If emailAddr is not null then it is used to identify the customer. If the email address
     * belongs to a registered customer, then a KKException is thrown. In this case the user must be
     * logged in and the sessionId parameter must be set to a valid value.</li>
     * </ol>
     * Note that the above parameters are exclusive and will be processed in the order displayed.
     * 
     * @param options
     *            Contains the method parameters.
     * @throws KKException
     */
     public void deleteCustomerNotifications(NotificationOptionsIf options) throws KKException
     {
         try
         {
            if (_deleteCustomerNotifications == null)
            {
                _deleteCustomerNotifications = new DeleteCustomerNotifications(kkEng);
            }

            _deleteCustomerNotifications.deleteCustomerNotifications(options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns the address format template for the numeric id passed in as a parameter. Returns null
     * if the template doesn't exist.
     * 
     * @param templateId
     *            Numeric id of the template
     * @return Returns the address format template for the numeric id passed in as a parameter.
     *         Returns null if the template doesn't exist.
     * @throws KKException
     */
     public String getAddressFormatTemplate(int templateId) throws KKException
     {
         try
         {
            if (_getAddressFormatTemplate == null)
            {
                _getAddressFormatTemplate = new GetAddressFormatTemplate(kkEng);
            }

            return _getAddressFormatTemplate.getAddressFormatTemplate(templateId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The method fetches an array of bundles (products of type bundle), all of which contain the
     * product with id <code>productId</code> as one of the bundled products. Each of the returned
     * products has the <code>bundledProducts</code> attribute populated with all of the bundled
     * products. The <code>quantity</code> attribute of each bundled product determines the number
     * of instances of the product within the bundle and the <code>encodedOptionValues</code>
     * attribute of each bundled product contains a string with the encoded option values
     * determining the configuration of the product (e.g size, color etc.).<br>
     * The options object contains an attribute called <code>createListOfUniqueProducts</code> which
     * may be used to configure the API call. This method returns an array of products, each of
     * which has an array of bundled products. The same products may be repeated many times within
     * the array of bundled products which can affect performance since the amount of data returned
     * can be very large. When <code>createListOfUniqueProducts</code> is set to true, the bundled
     * products are only populated with the product id, the quantity and the encodedOptionValues to
     * make them very much lighter. Also within the Products return object the
     * <code>uniqueProductArray</code> attribute is created and populated with a unique set of
     * products that includes just one copy of all of the bundled products.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order. It may be null, in which case, the number of retrieved products is
     *            limited to a default number and the offset is set to zero.
     * @param productId
     *            The numeric id of the product
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object containing an array of products, each with a populated
     *         <code>bundledProducts</code> attribute containing the products within the bundle. The
     *         <code>uniqueProductArray</code> attribute may be populated if
     *         <code>createListOfUniqueProducts</code> is set to true in the options object passed
     *         in as a parameter.
     * @throws KKException
     */
     public ProductsIf getBundlesThatProductBelongsTo(String sessionId, DataDescriptorIf dataDesc, int productId, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBundlesThatProductBelongsTo == null)
            {
                _getBundlesThatProductBelongsTo = new GetBundlesThatProductBelongsTo(kkEng);
            }

            return _getBundlesThatProductBelongsTo.getBundlesThatProductBelongsTo(sessionId, dataDesc, productId, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * The method fetches an array of bundles (products of type bundle), all of which contain the
     * products with ids <code>productIds</code> as one or more of the bundled products. Each of the
     * returned products has the <code>bundledProducts</code> attribute populated with all of the
     * bundled products. The <code>quantity</code> attribute of each bundled product determines the
     * number of instances of the product within the bundle and the <code>encodedOptionValues</code>
     * attribute of each bundled product contains a string with the encoded option values
     * determining the configuration of the product (e.g size, color etc.).<br>
     * The options object contains an attribute called <code>createListOfUniqueProducts</code> which
     * may be used to configure the API call. This method returns an array of products, each of
     * which has an array of bundled products. The same products may be repeated many times within
     * the array of bundled products which can affect performance since the amount of data returned
     * can be very large. When <code>createListOfUniqueProducts</code> is set to true, the bundled
     * products are only populated with the product id, the quantity and the encodedOptionValues to
     * make them very much lighter. Also within the Products return object the
     * <code>uniqueProductArray</code> attribute is created and populated with a unique set of
     * products that includes just one copy of all of the bundled products.
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param dataDesc
     *            Used to control the data offset, limit the number of items returned and set the
     *            sort order. It may be null, in which case, the number of retrieved products is
     *            limited to a default number and the offset is set to zero.
     * @param productIds
     *            The numeric ids of the products that are in the bundle
     * @param exactMatch
     *            Determines whether the call should return only bundles which contain exactly the
     *            products sent in the array of product IDs, or return all the bundles which contain
     *            at least all the products in the passed product IDs.
     * @param languageId
     *            The id for the language that will be used. Value of -1 selects the default
     *            language.
     * @param options
     *            An object containing options for the method. It may be set to null.
     * @return Returns a Products object containing an array of products, each with a populated
     *         <code>bundledProducts</code> attribute containing the products within the bundle. The
     *         <code>uniqueProductArray</code> attribute may be populated if
     *         <code>createListOfUniqueProducts</code> is set to true in the options object passed
     *         in as a parameter.
     * @throws KKException
     */
     public ProductsIf getBundlesThatProductsBelongTo(String sessionId, DataDescriptorIf dataDesc, int[] productIds, boolean exactMatch, int languageId, FetchProductOptionsIf options) throws KKException
     {
         try
         {
            if (_getBundlesThatProductsBelongTo == null)
            {
                _getBundlesThatProductsBelongTo = new GetBundlesThatProductsBelongTo(kkEng);
            }

            return _getBundlesThatProductsBelongTo.getBundlesThatProductsBelongTo(sessionId, dataDesc, productIds, exactMatch, languageId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get the image file names associated with the product whose id is specified. Only return image
     * file names that match the specified regular expression if specified and not null. If the file
     * name filter is null, all file names associated with the product are returned. If no product
     * exists with the specified productId an exception is thrown. If no files are found for the
     * product an empty array of image names is returned in the ProductImages return object.
     * 
     * @param options
     *            a ProductImagesOptions object for specifying the criteria used to define which
     *            product images should be returned. Within this search object you can specify
     *            productId and a file name filter (which is a regular expression).
     * @return a ProductImages object that contains an array of image file names associated with the
     *         specified product and matching the (possibly) specified name filter regular
     *         expression.
     * @throws KKException
     *             if options is null or if no product with the specified productId can be found or
     *             the store is currently unavailable.
     */
     public ProductImagesIf getProductImages(ProductImagesOptionsIf options) throws KKException
     {
         try
         {
            if (_getProductImages == null)
            {
                _getProductImages = new GetProductImages(kkEng);
            }

            return _getProductImages.getProductImages(options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Insert an event
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param event
     *            a KKEvent object
     * @return the id of the inserted event
     * @throws Exception
     */
     public int insertKKEvent(String sessionId, KKEventIf event) throws Exception
     {
         try
         {
            if (_insertKKEvent == null)
            {
                _insertKKEvent = new InsertKKEvent(kkEng);
            }

            return _insertKKEvent.insertKKEvent(sessionId, event);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Search for events
     * 
     * @param sessionId
     *            The session id of the logged in user
     * @param search
     *            KKEventSearchIf search object that defines the records to retrieve
     * @param desc
     *            DataDescriptorIf generic search object that can be used to set the offset, limit
     *            and order by clauses. Options for order by are:
     *            <ul>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_CODE_ASCENDING</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_CODE_DESCENDING</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_DATE_ADDED_ASCENDING</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_DATE_ADDED_DESCENDING</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_ID</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     *            <li>com.konakart.app.DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     *            </ul>
     * @return an array of KKEvent objects that meet the selection criteria
     * @throws Exception
     */
     public KKEventIf[] getKKEvents(String sessionId, KKEventSearchIf search, DataDescriptorIf desc) throws Exception
     {
         try
         {
            if (_getKKEvents == null)
            {
                _getKKEvents = new GetKKEvents(kkEng);
            }

            return _getKKEvents.getKKEvents(sessionId, search, desc);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * To force the processing of KKEvents
     * 
     * @param sessionId
     * @throws Exception
     */
     public void processKKEvents(String sessionId) throws Exception
     {
         try
         {
            if (_processKKEvents == null)
            {
                _processKKEvents = new ProcessKKEvents(kkEng);
            }

            _processKKEvents.processKKEvents(sessionId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method validates the password of a logged in customer and can be used to force the
     * customer to enter his password before allowing certain actions like the modification of the
     * customer's email address.
     * <p>
     * The method returns true if the password validates against the session. If either the session
     * is invalid or the password and session don't match, then the method returns false.
     * 
     * @param sessionId
     * @param password
     * @return Returns true if the password validates
     * @throws KKException
     */
     public boolean validatePassword(String sessionId, String password) throws KKException
     {
         try
         {
            if (_validatePassword == null)
            {
                _validatePassword = new ValidatePassword(kkEng);
            }

            return _validatePassword.validatePassword(sessionId, password);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns an array of coupons for the coupon code passed in as a parameter.
     * <p>
     * The options object allows you to specify that only active coupons should be returned.
     * 
     * @param couponCode
     *            The code of the coupon
     * @param options
     *            Allows you to specify that only active coupons should be returned
     * @return Returns an array of coupons. An empty array is returned if no coupons are available.
     * @throws KKException
     */
     public CouponIf[] getCouponsPerCode(String couponCode, CouponOptionsIf options) throws KKException
     {
         try
         {
            if (_getCouponsPerCode == null)
            {
                _getCouponsPerCode = new GetCouponsPerCode(kkEng);
            }

            return _getCouponsPerCode.getCouponsPerCode(couponCode, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Returns a coupon for the coupon id passed in as a parameter.
     * <p>
     * The options object allows you to specify that only active coupons should be returned.
     * 
     * @param couponId
     *            The unique numeric id of the coupon
     * @param options
     *            Allows you to specify that only active coupons should be returned
     * @return Returns a coupon object or null if a coupon isn't available.
     * @throws KKException
     */
     public CouponIf getCouponPerId(int couponId, CouponOptionsIf options) throws KKException
     {
         try
         {
            if (_getCouponPerId == null)
            {
                _getCouponPerId = new GetCouponPerId(kkEng);
            }

            return _getCouponPerId.getCouponPerId(couponId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * This method is used to return an array of promotions associated with the coupon(s) identified
     * by the input parameters. The method will either use the couponCode or the couponId parameter.
     * The couponCode is used if not null, otherwise couponId is used. Note that multiple coupons
     * may share the same coupon code.
     * <p>
     * The PromotionOptions may be used to control whether or not to use expired coupons and whether
     * or not to return expired promotions. The default is to not check whether coupons or
     * promotions have expired.
     * <p>
     * If no promotions are found, an empty array is returned.
     * 
     * @param couponCode
     *            The code of the coupon
     * @param couponId
     *            The unique numeric id of the coupon
     * @param options
     *            A PromotionOptions object to control whether or not to use expired coupons and
     *            whether or not to return expired promotions
     * @return Returns an array of promotions
     * @throws KKException
     */
     public PromotionIf[] getPromotionsPerCoupon(String couponCode, int couponId, PromotionOptionsIf options) throws KKException
     {
         try
         {
            if (_getPromotionsPerCoupon == null)
            {
                _getPromotionsPerCoupon = new GetPromotionsPerCoupon(kkEng);
            }

            return _getPromotionsPerCoupon.getPromotionsPerCoupon(couponCode, couponId, options);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Get the latest (last to be inserted) enabled Content record with the specified contentId for
     * the specified languageId. Content Dates are not checked.
     * 
     * @param contentId
     * @param languageId
     *            the languageId of the Content to return (Content Descriptions are
     *            language-specific). If KKConstants.DEFAULT_LANGUAGE_ID is used the default
     *            languageId is used).
     * @return a ContentIf object or a null if no matching content could be found.
     * @throws KKException
     */
     public ContentIf getContent(int contentId, int languageId) throws KKException
     {
         try
         {
            if (_getContent == null)
            {
                _getContent = new GetContent(kkEng);
            }

            return _getContent.getContent(contentId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Retrieve Content records using the specified search criteria
     * 
     * @param sessionId
     *            the sessionId of the customer. This may be used to look up the customer in order
     *            to evaluate expressions to determine the required content. Set to null if the
     *            customer isn't logged in.
     * @param search
     *            the content search criteria
     * @param dd
     *            the data descriptor object. In the DataDescriptor there is an attribute called
     *            limit where you define the maximum number of records to return from the database.
     *            Note that expressions are evaluated after the records are retrieved so fewer
     *            records than the maximum requested may be returned if your content is linked to
     *            expressions, you choose to evaluate them and some evaluate to false.
     *            <p>
     *            You can set the OrderBy attribute on the DataDescriptor to define the order that
     *            the content records will be returned. Options are:
     *            <ul>
     *            <li>DataDescConstants.ORDER_BY_ID (the default)</li>
     *            <li>DataDescConstants.ORDER_BY_ID_DESCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_ID_ASCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CONTENT_TYPE_ID_ASCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CONTENT_TYPE_ID_DESCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CUSTOM1_ASCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CUSTOM1_DESCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CUSTOM2_ASCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_CUSTOM2_DESCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_LAST_MODIFIED_ASCENDING</li>
     *            <li>DataDescConstants.ORDER_BY_LAST_MODIFIED_DESCENDING</li>
     *            </ul>
     * @return search results in a ContentSearchResultIf object
     * @throws KKException
     */
     public ContentSearchResultIf getContents(String sessionId, ContentSearchIf search, DataDescriptorIf dd) throws KKException
     {
         try
         {
            if (_getContents == null)
            {
                _getContents = new GetContents(kkEng);
            }

            return _getContents.getContents(sessionId, search, dd);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return the ContentType for the specified language and contentTypeId
     * 
     * @param contentTypeId
     *            the ContentTypeId
     * @param languageId
     *            the languageId of the ContentType to return (Content Type Descriptions are
     *            language-specific). If KKConstants.DEFAULT_LANGUAGE_ID is used the default
     *            languageId is used).
     * @return a ContentTypeIf object
     * @throws KKException
     */
     public ContentTypeIf getContentType(int contentTypeId, int languageId) throws KKException
     {
         try
         {
            if (_getContentType == null)
            {
                _getContentType = new GetContentType(kkEng);
            }

            return _getContentType.getContentType(contentTypeId, languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

    /**
     * Return all the ContentTypes for the specified language
     * 
     * @param languageId
     *            the languageId of the ContentTypes to return (Content Type Descriptions are
     *            language-specific). If KKConstants.DEFAULT_LANGUAGE_ID is used the default
     *            languageId is used).
     * @return an array of ContenttypeIf objects; An empty array may be returned but never a null.
     * @throws KKException
     */
     public ContentTypeIf[] getContentTypes(int languageId) throws KKException
     {
         try
         {
            if (_getContentTypes == null)
            {
                _getContentTypes = new GetContentTypes(kkEng);
            }

            return _getContentTypes.getContentTypes(languageId);
         } catch (Throwable e)
         {
            throw manageThrowable(e);
         }
     }

}
